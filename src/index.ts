import { MapInterface } from './MapInterface';
import { textToMarker } from './leaflet/markers';



declare var L: any;
declare var ol: any;

export interface QueryObject {
  [key: string]: Array<String> | String | Array<QueryObject> | Number | Boolean,
  entityType: String,
  filter?: String,
  select?: Array<String>,
  expand?: Array<QueryObject>
  top?: Number,
  skip?: Number,
  count?: Boolean,
  id?: Number
}

export interface Config {
  cluster: Boolean,
  clusterMin: number,
  queryObject: QueryObject;
  baseUrl: String,
  markerStyle?: Function | object,
  clusterStyle?: Function | object,
  markerMouseOver?: Function,
  markerClick?: Function,
  clusterMouseOver?: Function,
  clusterClick?: Function,
  map?: any
}

//Leaflet
if (typeof L !== "undefined") {
  //All leaflet layers are stored in
  var layers: any = [];
  //Layer that represents all count circles and tooltips
  var countLayer: any;
  //Extend a LayerGroup
  (L as any).Stam = L.LayerGroup.extend({
    initialize: function (config: Config) {
      var mapInterface = new MapInterface(config);

      var highlight: Boolean;

      //Used for setting the style of a polygon when it is hovered
      var setHighlight = function (layer: any) {
        // Check if something's highlighted, if so unset highlight
        if (highlight) {
          unsetHighlight(highlight);
        }
        // Set highlight style on layer and store to variable
        layer.setStyle(style.highlight);
        highlight = layer;
      }

      //Remove the style after the mouse hovered over a polygon
      var unsetHighlight = function (layer: any) {
        // Set default style and clear variable
        layer.setStyle(style.default);
        highlight = null;
      }

      //TODO use style from config
      var style = {
        'default': {
          'opacity': 0,
          'fillOpacity': 0
        },
        'highlight': {
          'color': 'red',
          'opacity': 1,
        }
      };

      //Called when the layer is added to the map
      this.on('add', function () {
        if (this._map != undefined) {

          //Flag if the countLayer should be cleared
          var clearCluster: boolean;

          var map = this._map;

          var zoom = map.getZoom();

          //Called on every feature of the map
          var onEachFeature = (feature: any, layer: any) => {
            //Check if the countLayer should be cleared
            if (clearCluster) {
              countLayer.clearLayers();
              clearCluster = false;
            }

            //Check if a polygon is cluster generated by the library and a polygon
            if (feature.geometry?.type == 'Polygon' && feature.properties.count) {
              //Check for mouse hover
              layer.on('mouseover', function () {
                if (config.clusterMouseOver) config.clusterMouseOver(feature);

                //Highlight the polygon with the given style
                setHighlight(layer);
              });

              layer.on('mouseout', function () {
                unsetHighlight(layer);
              });

              layer.on('click', function () {

                //Configure a click on the cluster, if nothing is configured or nothing returned, the map zooms to the bounds of the polygon 
                if (config.clusterClick) {
                  var out = config.clusterClick(feature);
                  if (out)
                    return layer.bindPopup(out);
                }
                map.fitBounds(layer.getBounds());
              });

              //Set the default style of a polygon
              layer.setStyle(style.default);

              //Get the bounds and calculate the center of the polygon
              var bounds = layer.getBounds();
              var lat = (bounds._northEast.lat + bounds._southWest.lat) / 2;
              var lng = (bounds._northEast.lng + bounds._southWest.lng) / 2;

              //Position a circle in the center
              var circle = L.circleMarker(L.latLng(lat, lng), {
                radius: zoom * 3
              });

              //Add the count of things inside the polygon to the circle
              circle.bindTooltip(`<span>${feature.properties.count}</span>`, { permanent: true, direction: "center", className: 'count' });

              //Add the circle to the countLayer
              countLayer.addLayer(circle);
            } else {

              //Add a click event to the markers
              layer.on('click', function () {
                //Bind popup with functions return if present
                if (config.markerClick) {
                  var out = config.markerClick(feature);
                  if (out)
                    return layer.bindPopup(out);
                }

                //Default behavior 
                layer.bindPopup(`<span>${JSON.stringify(feature.properties)}</span>`);
              });

              layer.on('mouseover', function () {
                if (config.markerMouseOver) return config.markerMouseOver(feature);
              });
            }
          };

          //Used for marker styling
          var pointToLayer = function (feature: any, latlng: any) {
            //Marker coloring
            var marker = L.marker(latlng, { icon: typeof config.markerStyle == 'function' ? textToMarker(config.markerStyle(feature)) : typeof config.markerStyle == 'string' ? textToMarker(config.markerStyle) : new L.Icon.Default() });
            return marker;
          }

          //Called when the LayerGroup was added to the map, then the LayerGroup's super class is done initiating 
          map.on('layeradd', function () {
            //Remove callback
            map.off('layeradd');

            //Initiade the count layer and add it to this layer group
            countLayer = L.layerGroup();
            this.addLayer(countLayer);

            //Initiate the layer group with the current bounds and zoom level
            var bounds = map.getBounds();
            mapInterface.getLayerData(map.getZoom(), [bounds._northEast.lng, bounds._northEast.lat, bounds._southWest.lng, bounds._southWest.lat]).then((geojson: any) => {

              //Create a geoJson layer and add it to the layers array and to this layer group
              var geoJsonLayer = L.geoJSON(geojson, {
                onEachFeature,
                pointToLayer,
                style: config.clusterStyle
              });
              layers.push(geoJsonLayer);
              this.addLayer(geoJsonLayer);
            });
          });


          //Called when zoom ended or the map was moved. The geojson layer is removed and a new one added, because the loaded geojson's are cached inside the MapInterface
          map.on('moveend', function () {
            //Update the zoom variable if the zoom was changed
            if (zoom != map.getZoom()) {
              zoom = map.getZoom();
            }
            //Set flag to true so that the cluster labels are removed
            clearCluster = true;
            var bounds = map.getBounds();

            //add a new layer and remove all old layers
            mapInterface.getLayerData(map.getZoom(), [bounds._northEast.lng, bounds._northEast.lat, bounds._southWest.lng, bounds._southWest.lat]).then((geojson: any) => {
              var geoJsonLayer = L.geoJSON(geojson, {
                onEachFeature,
                pointToLayer,
                style: config.clusterStyle
              });
              layers.forEach((layer: any) => {
                layer.remove();
              });
              layers.push(geoJsonLayer);
              this.addLayer(geoJsonLayer);
            });
          });
        }
      });
    },

  });

  (L as any).stam = function (config: Config) {
    return new (L as any).Stam(config);
  }

  //Adding custom css to head, so that the count tooltipp's background is transparent
  var css = '.leaflet-tooltip.count {background-color: transparent;border: transparent;  box-shadow: none;  font-weight: bold;font-size: 20px;}',
    head = document.head || document.getElementsByTagName('head')[0],
    style: any = document.createElement('style');

  head.appendChild(style);

  style.type = 'text/css';
  if (style.styleSheet) {
    // This is required for IE8 and below.
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

if (typeof ol != "undefined") {

  //Since ol 6 ol.inherits was removed
  var ol_ext_inherits = function (child: any, parent: any) {
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child;
  };

  var zoom: number;
  //Contains all layers that where added by the library, this.getLayers() returns all layers
  var olLayers: any = [];

  var olmap: any;

  /**
   * STAM implementation for openLayers
   * @param config STAM configuration object
   */
  var ol_layer_stam = function (config: Config) {
    //Get map instance from config
    olmap = config.map;

    //Init LayerGroup
    ol.layer.Group.call(this, config);

    //Get current zoom level and remove all decimal places
    zoom = olmap.getView().getZoom().toFixed(0);

    var mapInterface = new MapInterface(config);

    //Add listener to moveend, called when moving and zooming;
    olmap.on("moveend", function () {
      //Check if zoom level was changed
      if (zoom != olmap.getView().getZoom()) {
        zoom = olmap.getView().getZoom().toFixed(0);
      }

      //always add new layer, because the geojson is cached inside MapInterface.ts
      addSTAMLayer(mapInterface, zoom).then(function (layer: any) {
        this.getLayers().array_.push(layer);

        this.changed();

        //remove all old layers, if they are inside the olLayers array
        this.getLayers().array_ = this.getLayers().array_.filter(function (layer: any) {
          if (olLayers.indexOf(layer) != -1) {
            return false;
          }
          return true;
        }.bind(this));

        //Force a map render
        olmap.render();

        //Clear the olLayers array and push the new layer
        olLayers = [];
        olLayers.push(layer);

      }.bind(this));
    });
  };

  //Inherit the layer group from openLayers
  ol_ext_inherits(ol_layer_stam, ol.layer.Group);

  //Add the layer to ol.layer.STAM
  ol.layer.STAM = ol_layer_stam
}

/**
 * Creates a stam layer
 * @param mapInterface mapInterface instance
 * @param zoom current zoom level
 * @returns a promise that resolves with an openLayers vectorLayer that contains the geoJson
 */
function addSTAMLayer(mapInterface: MapInterface, zoom: number) {
  return new Promise(function (resolve, reject) {
    var bounds;

    //Check it the projection is EPSG 4326
    if (olmap.getView().getProjection().getCode() == "EPSG:4326")
      bounds = olmap.getView().calculateExtent();
    else {
      //If not convert the bounding box to EPSG 4326
      var zw = olmap.getView().calculateExtent();
      var code = olmap.getView().getProjection().getCode();
      bounds = [];
      bounds.push(...(new ol.geom.Point([zw[2], zw[3]])).transform(code, 'EPSG:4326').getCoordinates());
      bounds.push(...(new ol.geom.Point([zw[0], zw[1]])).transform(code, 'EPSG:4326').getCoordinates());
    }


    //Fetch the geojson
    mapInterface.getLayerData(zoom, bounds).then((geoJson: any) => {

      //Create the geojson with  geojson and set the featureProjection to the view's projection
      var vectorSource = new ol.source.Vector({
        features: new ol.format.GeoJSON().readFeatures(geoJson, { featureProjection: olmap.getView().getProjection().getCode() }),
      });

      var style = new ol.style.Style({
        image: new ol.style.Icon(({
          anchor: [12, 41],
          anchorXUnits: 'fraction',
          anchorYUnits: 'pixels',
          src: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png'
        })),
      })

      //Create the vectorLayer with the geojson vector source
      var vectorLayer = new ol.layer.Vector({
        source: vectorSource,
        style: (feature: any) => {
          console.log(feature.getGeometry());
          if (feature.getGeometry().getType() == "Point")
            return style;
          else
            return new ol.style.Style({
              stroke: new ol.style.Stroke({
                color: 'blue',
                lineDash: [4],
                width: 3,
              }),
              fill: new ol.style.Fill({
                color: 'rgba(0, 0, 255, 0.1)',
              }),
            });
        }
      });

      //Resolve the promise with the vector layer
      resolve(vectorLayer);
    });
  });
}

