(function () {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    var global$1 = (function(self) {
      return self
      // eslint-disable-next-line no-invalid-this
    })(typeof self !== 'undefined' ? self : undefined);
    var support = {
      searchParams: 'URLSearchParams' in global$1,
      iterable: 'Symbol' in global$1 && 'iterator' in Symbol,
      blob:
        'FileReader' in global$1 &&
        'Blob' in global$1 &&
        (function() {
          try {
            new Blob();
            return true
          } catch (e) {
            return false
          }
        })(),
      formData: 'FormData' in global$1,
      arrayBuffer: 'ArrayBuffer' in global$1
    };

    function isDataView(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    if (support.arrayBuffer) {
      var viewClasses = [
        '[object Int8Array]',
        '[object Uint8Array]',
        '[object Uint8ClampedArray]',
        '[object Int16Array]',
        '[object Uint16Array]',
        '[object Int32Array]',
        '[object Uint32Array]',
        '[object Float32Array]',
        '[object Float64Array]'
      ];

      var isArrayBufferView =
        ArrayBuffer.isView ||
        function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
        };
    }

    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }
      if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
        throw new TypeError('Invalid character in header field name')
      }
      return name.toLowerCase()
    }

    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }
      return value
    }

    // Build a destructive iterator for the value list
    function iteratorFor(items) {
      var iterator = {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value}
        }
      };

      if (support.iterable) {
        iterator[Symbol.iterator] = function() {
          return iterator
        };
      }

      return iterator
    }

    function Headers(headers) {
      this.map = {};

      if (headers instanceof Headers) {
        headers.forEach(function(value, name) {
          this.append(name, value);
        }, this);
      } else if (Array.isArray(headers)) {
        headers.forEach(function(header) {
          this.append(header[0], header[1]);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function(name) {
          this.append(name, headers[name]);
        }, this);
      }
    }

    Headers.prototype.append = function(name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ', ' + value : value;
    };

    Headers.prototype['delete'] = function(name) {
      delete this.map[normalizeName(name)];
    };

    Headers.prototype.get = function(name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null
    };

    Headers.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name))
    };

    Headers.prototype.set = function(name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };

    Headers.prototype.forEach = function(callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };

    Headers.prototype.keys = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push(name);
      });
      return iteratorFor(items)
    };

    Headers.prototype.values = function() {
      var items = [];
      this.forEach(function(value) {
        items.push(value);
      });
      return iteratorFor(items)
    };

    Headers.prototype.entries = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items)
    };

    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }

    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'))
      }
      body.bodyUsed = true;
    }

    function fileReaderReady(reader) {
      return new Promise(function(resolve, reject) {
        reader.onload = function() {
          resolve(reader.result);
        };
        reader.onerror = function() {
          reject(reader.error);
        };
      })
    }

    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise
    }

    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise
    }

    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);

      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }
      return chars.join('')
    }

    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0)
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer
      }
    }

    function Body() {
      this.bodyUsed = false;

      this._initBody = function(body) {
        /*
          fetch-mock wraps the Response object in an ES6 Proxy to
          provide useful test harness features such as flush. However, on
          ES5 browsers without fetch or Proxy support pollyfills must be used;
          the proxy-pollyfill is unable to proxy an attribute unless it exists
          on the object before the Proxy is created. This change ensures
          Response.bodyUsed exists on the instance, while maintaining the
          semantic of setting Request.bodyUsed in the constructor before
          _initBody is called.
        */
        this.bodyUsed = this.bodyUsed;
        this._bodyInit = body;
        if (!body) {
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          // IE 10-11 can't handle a DataView body.
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          this._bodyText = body = Object.prototype.toString.call(body);
        }

        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };

      if (support.blob) {
        this.blob = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected
          }

          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob)
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]))
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob')
          } else {
            return Promise.resolve(new Blob([this._bodyText]))
          }
        };

        this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
          } else {
            return this.blob().then(readBlobAsArrayBuffer)
          }
        };
      }

      this.text = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      };

      if (support.formData) {
        this.formData = function() {
          return this.text().then(decode)
        };
      }

      this.json = function() {
        return this.text().then(JSON.parse)
      };

      return this
    }

    // HTTP methods whose capitalization should be normalized
    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method
    }

    function Request(input, options) {
      options = options || {};
      var body = options.body;

      if (input instanceof Request) {
        if (input.bodyUsed) {
          throw new TypeError('Already read')
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        this.signal = input.signal;
        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      } else {
        this.url = String(input);
      }

      this.credentials = options.credentials || this.credentials || 'same-origin';
      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }
      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.signal = options.signal || this.signal;
      this.referrer = null;

      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests')
      }
      this._initBody(body);

      if (this.method === 'GET' || this.method === 'HEAD') {
        if (options.cache === 'no-store' || options.cache === 'no-cache') {
          // Search for a '_' parameter in the query string
          var reParamSearch = /([?&])_=[^&]*/;
          if (reParamSearch.test(this.url)) {
            // If it already exists then set the value with the current time
            this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
          } else {
            // Otherwise add a new '_' parameter to the end with the current time
            var reQueryString = /\?/;
            this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
          }
        }
      }
    }

    Request.prototype.clone = function() {
      return new Request(this, {body: this._bodyInit})
    };

    function decode(body) {
      var form = new FormData();
      body
        .trim()
        .split('&')
        .forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split('=');
            var name = split.shift().replace(/\+/g, ' ');
            var value = split.join('=').replace(/\+/g, ' ');
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
      return form
    }

    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
      // https://tools.ietf.org/html/rfc7230#section-3.2
      var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
      preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
      return headers
    }

    Body.call(Request.prototype);

    function Response(bodyInit, options) {
      if (!options) {
        options = {};
      }

      this.type = 'default';
      this.status = options.status === undefined ? 200 : options.status;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = 'statusText' in options ? options.statusText : '';
      this.headers = new Headers(options.headers);
      this.url = options.url || '';
      this._initBody(bodyInit);
    }

    Body.call(Response.prototype);

    Response.prototype.clone = function() {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      })
    };

    Response.error = function() {
      var response = new Response(null, {status: 0, statusText: ''});
      response.type = 'error';
      return response
    };

    var redirectStatuses = [301, 302, 303, 307, 308];

    Response.redirect = function(url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code')
      }

      return new Response(null, {status: status, headers: {location: url}})
    };

    var DOMException = global$1.DOMException;

    if (typeof DOMException !== 'function') {
      DOMException = function(message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
      };
      DOMException.prototype = Object.create(Error.prototype);
      DOMException.prototype.constructor = DOMException;
    }

    function fetch$1(input, init) {
      return new Promise(function(resolve, reject) {
        var request = new Request(input, init);

        if (request.signal && request.signal.aborted) {
          return reject(new DOMException('Aborted', 'AbortError'))
        }

        var xhr = new XMLHttpRequest();

        function abortXhr() {
          xhr.abort();
        }

        xhr.onload = function() {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          setTimeout(function() {
            resolve(new Response(body, options));
          }, 0);
        };

        xhr.onerror = function() {
          setTimeout(function() {
            reject(new TypeError('Network request failed'));
          }, 0);
        };

        xhr.ontimeout = function() {
          setTimeout(function() {
            reject(new TypeError('Network request failed'));
          }, 0);
        };

        xhr.onabort = function() {
          setTimeout(function() {
            reject(new DOMException('Aborted', 'AbortError'));
          }, 0);
        };

        function fixUrl(url) {
          try {
            return url === '' && global$1.location.href ? global$1.location.href : url
          } catch (e) {
            return url
          }
        }

        xhr.open(request.method, fixUrl(request.url), true);

        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        } else if (request.credentials === 'omit') {
          xhr.withCredentials = false;
        }

        if ('responseType' in xhr) {
          if (support.blob) {
            xhr.responseType = 'blob';
          } else if (
            support.arrayBuffer &&
            request.headers.get('Content-Type') &&
            request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
          ) {
            xhr.responseType = 'arraybuffer';
          }
        }

        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });

        if (request.signal) {
          request.signal.addEventListener('abort', abortXhr);

          xhr.onreadystatechange = function() {
            // DONE (success or failure)
            if (xhr.readyState === 4) {
              request.signal.removeEventListener('abort', abortXhr);
            }
          };
        }

        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      })
    }

    fetch$1.polyfill = true;

    if (!global$1.fetch) {
      global$1.fetch = fetch$1;
      global$1.Headers = Headers;
      global$1.Request = Request;
      global$1.Response = Response;
    }

    /**
     * Used for creating a link from a QueryObject
     */
    class QueryGenerator {
        constructor(query) {
            this.queryObject = query;
        }
        /**
         * Returns a string for a sensorthings server query
         * @param main defaults to true, used for specifying if the queries should be appended to the end or added inside the brackets
         * @returns link prefix
         */
        toString(main = true) {
            var url = this.queryObject.entityType;
            var prefix = [];
            // Adding id if present
            if (this.queryObject.id) {
                if (main) {
                    url = `${url}(${this.queryObject.id})`;
                    delete this.queryObject.id;
                }
                else {
                    //If not in main, no other attributes can be added
                    return `${this.queryObject.entityType}(${this.queryObject.id})`;
                }
            }
            for (var key in this.queryObject) {
                //Remove empty properties
                if ((!this.queryObject[key]) && this.queryObject[key] != 0)
                    continue;
                //Select
                if (key == 'select') {
                    prefix.push(`$select=${this.queryObject.select.join(',')}`);
                    continue;
                }
                //Expand
                if (key == 'expand') {
                    prefix.push(`$expand=${this.queryObject.expand.map((queryObject) => {
                    return new QueryGenerator(queryObject).toString(false);
                }).join(',')}`);
                    continue;
                }
                //Every other property
                if (key != 'entityType') {
                    prefix.push(`$${key}=${this.queryObject[key].toString()}`);
                }
            }
            //Check if a prefix is present
            if (prefix.length == 0) {
                return url;
            }
            //Return right url string
            if (main) {
                return `${url}?${prefix.map(encodeURI).join('&')}`;
            }
            else {
                return `${url}(${prefix.map(encodeURI).join(';')})`;
            }
        }
    }

    /**
     * Used for querying a sensorthings server, that may return a next link
     */
    class STAInterface {
        constructor(baseUrl) {
            this.baseUrl = baseUrl;
        }
        getGeoJson(query) {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                //Generate url
                var url = `${this.baseUrl}/${(new QueryGenerator(query).toString())}`;
                //get data
                var data = yield (yield fetch(url)).json();
                var link = data['@iot.nextLink'];
                //Get data as long as a next link is present
                while (link) {
                    var response = yield (yield fetch(link)).json();
                    //Push data in existing value array
                    data.value.push(...response.value);
                    //Update next link
                    link = response['@iot.nextLink'];
                }
                resolve(data);
            }));
        }
    }

    /**
     * splaytree v3.0.1
     * Fast Splay tree for Node and browser
     *
     * @author Alexander Milevski <info@w8r.name>
     * @license MIT
     * @preserve
     */

    class Node$1 {
        constructor(key, data) {
            this.next = null;
            this.key = key;
            this.data = data;
            this.left = null;
            this.right = null;
        }
    }

    /* follows "An implementation of top-down splaying"
     * by D. Sleator <sleator@cs.cmu.edu> March 1992
     */
    function DEFAULT_COMPARE(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
    }
    /**
     * Simple top down splay, not requiring i to be in the tree t.
     */
    function splay(i, t, comparator) {
        const N = new Node$1(null, null);
        let l = N;
        let r = N;
        while (true) {
            const cmp = comparator(i, t.key);
            //if (i < t.key) {
            if (cmp < 0) {
                if (t.left === null)
                    break;
                //if (i < t.left.key) {
                if (comparator(i, t.left.key) < 0) {
                    const y = t.left; /* rotate right */
                    t.left = y.right;
                    y.right = t;
                    t = y;
                    if (t.left === null)
                        break;
                }
                r.left = t; /* link right */
                r = t;
                t = t.left;
                //} else if (i > t.key) {
            }
            else if (cmp > 0) {
                if (t.right === null)
                    break;
                //if (i > t.right.key) {
                if (comparator(i, t.right.key) > 0) {
                    const y = t.right; /* rotate left */
                    t.right = y.left;
                    y.left = t;
                    t = y;
                    if (t.right === null)
                        break;
                }
                l.right = t; /* link left */
                l = t;
                t = t.right;
            }
            else
                break;
        }
        /* assemble */
        l.right = t.left;
        r.left = t.right;
        t.left = N.right;
        t.right = N.left;
        return t;
    }
    function insert(i, data, t, comparator) {
        const node = new Node$1(i, data);
        if (t === null) {
            node.left = node.right = null;
            return node;
        }
        t = splay(i, t, comparator);
        const cmp = comparator(i, t.key);
        if (cmp < 0) {
            node.left = t.left;
            node.right = t;
            t.left = null;
        }
        else if (cmp >= 0) {
            node.right = t.right;
            node.left = t;
            t.right = null;
        }
        return node;
    }
    function split(key, v, comparator) {
        let left = null;
        let right = null;
        if (v) {
            v = splay(key, v, comparator);
            const cmp = comparator(v.key, key);
            if (cmp === 0) {
                left = v.left;
                right = v.right;
            }
            else if (cmp < 0) {
                right = v.right;
                v.right = null;
                left = v;
            }
            else {
                left = v.left;
                v.left = null;
                right = v;
            }
        }
        return { left, right };
    }
    function merge(left, right, comparator) {
        if (right === null)
            return left;
        if (left === null)
            return right;
        right = splay(left.key, right, comparator);
        right.left = left;
        return right;
    }
    /**
     * Prints level of the tree
     */
    function printRow(root, prefix, isTail, out, printNode) {
        if (root) {
            out(`${prefix}${isTail ? '└── ' : '├── '}${printNode(root)}\n`);
            const indent = prefix + (isTail ? '    ' : '│   ');
            if (root.left)
                printRow(root.left, indent, false, out, printNode);
            if (root.right)
                printRow(root.right, indent, true, out, printNode);
        }
    }
    class Tree {
        constructor(comparator = DEFAULT_COMPARE) {
            this._root = null;
            this._size = 0;
            this._comparator = comparator;
        }
        /**
         * Inserts a key, allows duplicates
         */
        insert(key, data) {
            this._size++;
            return this._root = insert(key, data, this._root, this._comparator);
        }
        /**
         * Adds a key, if it is not present in the tree
         */
        add(key, data) {
            const node = new Node$1(key, data);
            if (this._root === null) {
                node.left = node.right = null;
                this._size++;
                this._root = node;
            }
            const comparator = this._comparator;
            const t = splay(key, this._root, comparator);
            const cmp = comparator(key, t.key);
            if (cmp === 0)
                this._root = t;
            else {
                if (cmp < 0) {
                    node.left = t.left;
                    node.right = t;
                    t.left = null;
                }
                else if (cmp > 0) {
                    node.right = t.right;
                    node.left = t;
                    t.right = null;
                }
                this._size++;
                this._root = node;
            }
            return this._root;
        }
        /**
         * @param  {Key} key
         * @return {Node|null}
         */
        remove(key) {
            this._root = this._remove(key, this._root, this._comparator);
        }
        /**
         * Deletes i from the tree if it's there
         */
        _remove(i, t, comparator) {
            let x;
            if (t === null)
                return null;
            t = splay(i, t, comparator);
            const cmp = comparator(i, t.key);
            if (cmp === 0) { /* found it */
                if (t.left === null) {
                    x = t.right;
                }
                else {
                    x = splay(i, t.left, comparator);
                    x.right = t.right;
                }
                this._size--;
                return x;
            }
            return t; /* It wasn't there */
        }
        /**
         * Removes and returns the node with smallest key
         */
        pop() {
            let node = this._root;
            if (node) {
                while (node.left)
                    node = node.left;
                this._root = splay(node.key, this._root, this._comparator);
                this._root = this._remove(node.key, this._root, this._comparator);
                return { key: node.key, data: node.data };
            }
            return null;
        }
        /**
         * Find without splaying
         */
        findStatic(key) {
            let current = this._root;
            const compare = this._comparator;
            while (current) {
                const cmp = compare(key, current.key);
                if (cmp === 0)
                    return current;
                else if (cmp < 0)
                    current = current.left;
                else
                    current = current.right;
            }
            return null;
        }
        find(key) {
            if (this._root) {
                this._root = splay(key, this._root, this._comparator);
                if (this._comparator(key, this._root.key) !== 0)
                    return null;
            }
            return this._root;
        }
        contains(key) {
            let current = this._root;
            const compare = this._comparator;
            while (current) {
                const cmp = compare(key, current.key);
                if (cmp === 0)
                    return true;
                else if (cmp < 0)
                    current = current.left;
                else
                    current = current.right;
            }
            return false;
        }
        forEach(visitor, ctx) {
            let current = this._root;
            const Q = []; /* Initialize stack s */
            let done = false;
            while (!done) {
                if (current !== null) {
                    Q.push(current);
                    current = current.left;
                }
                else {
                    if (Q.length !== 0) {
                        current = Q.pop();
                        visitor.call(ctx, current);
                        current = current.right;
                    }
                    else
                        done = true;
                }
            }
            return this;
        }
        /**
         * Walk key range from `low` to `high`. Stops if `fn` returns a value.
         */
        range(low, high, fn, ctx) {
            const Q = [];
            const compare = this._comparator;
            let node = this._root;
            let cmp;
            while (Q.length !== 0 || node) {
                if (node) {
                    Q.push(node);
                    node = node.left;
                }
                else {
                    node = Q.pop();
                    cmp = compare(node.key, high);
                    if (cmp > 0) {
                        break;
                    }
                    else if (compare(node.key, low) >= 0) {
                        if (fn.call(ctx, node))
                            return this; // stop if smth is returned
                    }
                    node = node.right;
                }
            }
            return this;
        }
        /**
         * Returns array of keys
         */
        keys() {
            const keys = [];
            this.forEach(({ key }) => keys.push(key));
            return keys;
        }
        /**
         * Returns array of all the data in the nodes
         */
        values() {
            const values = [];
            this.forEach(({ data }) => values.push(data));
            return values;
        }
        min() {
            if (this._root)
                return this.minNode(this._root).key;
            return null;
        }
        max() {
            if (this._root)
                return this.maxNode(this._root).key;
            return null;
        }
        minNode(t = this._root) {
            if (t)
                while (t.left)
                    t = t.left;
            return t;
        }
        maxNode(t = this._root) {
            if (t)
                while (t.right)
                    t = t.right;
            return t;
        }
        /**
         * Returns node at given index
         */
        at(index) {
            let current = this._root;
            let done = false;
            let i = 0;
            const Q = [];
            while (!done) {
                if (current) {
                    Q.push(current);
                    current = current.left;
                }
                else {
                    if (Q.length > 0) {
                        current = Q.pop();
                        if (i === index)
                            return current;
                        i++;
                        current = current.right;
                    }
                    else
                        done = true;
                }
            }
            return null;
        }
        next(d) {
            let root = this._root;
            let successor = null;
            if (d.right) {
                successor = d.right;
                while (successor.left)
                    successor = successor.left;
                return successor;
            }
            const comparator = this._comparator;
            while (root) {
                const cmp = comparator(d.key, root.key);
                if (cmp === 0)
                    break;
                else if (cmp < 0) {
                    successor = root;
                    root = root.left;
                }
                else
                    root = root.right;
            }
            return successor;
        }
        prev(d) {
            let root = this._root;
            let predecessor = null;
            if (d.left !== null) {
                predecessor = d.left;
                while (predecessor.right)
                    predecessor = predecessor.right;
                return predecessor;
            }
            const comparator = this._comparator;
            while (root) {
                const cmp = comparator(d.key, root.key);
                if (cmp === 0)
                    break;
                else if (cmp < 0)
                    root = root.left;
                else {
                    predecessor = root;
                    root = root.right;
                }
            }
            return predecessor;
        }
        clear() {
            this._root = null;
            this._size = 0;
            return this;
        }
        toList() {
            return toList(this._root);
        }
        /**
         * Bulk-load items. Both array have to be same size
         */
        load(keys, values = [], presort = false) {
            let size = keys.length;
            const comparator = this._comparator;
            // sort if needed
            if (presort)
                sort(keys, values, 0, size - 1, comparator);
            if (this._root === null) { // empty tree
                this._root = loadRecursive(keys, values, 0, size);
                this._size = size;
            }
            else { // that re-builds the whole tree from two in-order traversals
                const mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
                size = this._size + size;
                this._root = sortedListToBST({ head: mergedList }, 0, size);
            }
            return this;
        }
        isEmpty() { return this._root === null; }
        get size() { return this._size; }
        get root() { return this._root; }
        toString(printNode = (n) => String(n.key)) {
            const out = [];
            printRow(this._root, '', true, (v) => out.push(v), printNode);
            return out.join('');
        }
        update(key, newKey, newData) {
            const comparator = this._comparator;
            let { left, right } = split(key, this._root, comparator);
            if (comparator(key, newKey) < 0) {
                right = insert(newKey, newData, right, comparator);
            }
            else {
                left = insert(newKey, newData, left, comparator);
            }
            this._root = merge(left, right, comparator);
        }
        split(key) {
            return split(key, this._root, this._comparator);
        }
    }
    function loadRecursive(keys, values, start, end) {
        const size = end - start;
        if (size > 0) {
            const middle = start + Math.floor(size / 2);
            const key = keys[middle];
            const data = values[middle];
            const node = new Node$1(key, data);
            node.left = loadRecursive(keys, values, start, middle);
            node.right = loadRecursive(keys, values, middle + 1, end);
            return node;
        }
        return null;
    }
    function createList(keys, values) {
        const head = new Node$1(null, null);
        let p = head;
        for (let i = 0; i < keys.length; i++) {
            p = p.next = new Node$1(keys[i], values[i]);
        }
        p.next = null;
        return head.next;
    }
    function toList(root) {
        let current = root;
        const Q = [];
        let done = false;
        const head = new Node$1(null, null);
        let p = head;
        while (!done) {
            if (current) {
                Q.push(current);
                current = current.left;
            }
            else {
                if (Q.length > 0) {
                    current = p = p.next = Q.pop();
                    current = current.right;
                }
                else
                    done = true;
            }
        }
        p.next = null; // that'll work even if the tree was empty
        return head.next;
    }
    function sortedListToBST(list, start, end) {
        const size = end - start;
        if (size > 0) {
            const middle = start + Math.floor(size / 2);
            const left = sortedListToBST(list, start, middle);
            const root = list.head;
            root.left = left;
            list.head = list.head.next;
            root.right = sortedListToBST(list, middle + 1, end);
            return root;
        }
        return null;
    }
    function mergeLists(l1, l2, compare) {
        const head = new Node$1(null, null); // dummy
        let p = head;
        let p1 = l1;
        let p2 = l2;
        while (p1 !== null && p2 !== null) {
            if (compare(p1.key, p2.key) < 0) {
                p.next = p1;
                p1 = p1.next;
            }
            else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        if (p1 !== null) {
            p.next = p1;
        }
        else if (p2 !== null) {
            p.next = p2;
        }
        return head.next;
    }
    function sort(keys, values, left, right, compare) {
        if (left >= right)
            return;
        const pivot = keys[(left + right) >> 1];
        let i = left - 1;
        let j = right + 1;
        while (true) {
            do
                i++;
            while (compare(keys[i], pivot) < 0);
            do
                j--;
            while (compare(keys[j], pivot) > 0);
            if (i >= j)
                break;
            let tmp = keys[i];
            keys[i] = keys[j];
            keys[j] = tmp;
            tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
        }
        sort(keys, values, left, j, compare);
        sort(keys, values, j + 1, right, compare);
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    /**
     * A bounding box has the format:
     *
     *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }
     *
     */
    var isInBbox = function isInBbox(bbox, point) {
      return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
    };
    /* Returns either null, or a bbox (aka an ordered pair of points)
     * If there is only one point of overlap, a bbox with identical points
     * will be returned */

    var getBboxOverlap = function getBboxOverlap(b1, b2) {
      // check if the bboxes overlap at all
      if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values

      var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
      var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values

      var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
      var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap

      return {
        ll: {
          x: lowerX,
          y: lowerY
        },
        ur: {
          x: upperX,
          y: upperY
        }
      };
    };

    /* Javascript doesn't do integer math. Everything is
     * floating point with percision Number.EPSILON.
     *
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
     */
    var epsilon = Number.EPSILON; // IE Polyfill

    if (epsilon === undefined) epsilon = Math.pow(2, -52);
    var EPSILON_SQ = epsilon * epsilon;
    /* FLP comparator */

    var cmp = function cmp(a, b) {
      // check if they're both 0
      if (-epsilon < a && a < epsilon) {
        if (-epsilon < b && b < epsilon) {
          return 0;
        }
      } // check if they're flp equal


      var ab = a - b;

      if (ab * ab < EPSILON_SQ * a * b) {
        return 0;
      } // normal comparison


      return a < b ? -1 : 1;
    };

    /**
     * This class rounds incoming values sufficiently so that
     * floating points problems are, for the most part, avoided.
     *
     * Incoming points are have their x & y values tested against
     * all previously seen x & y values. If either is 'too close'
     * to a previously seen value, it's value is 'snapped' to the
     * previously seen value.
     *
     * All points should be rounded by this class before being
     * stored in any data structures in the rest of this algorithm.
     */

    var PtRounder = /*#__PURE__*/function () {
      function PtRounder() {
        _classCallCheck(this, PtRounder);

        this.reset();
      }

      _createClass(PtRounder, [{
        key: "reset",
        value: function reset() {
          this.xRounder = new CoordRounder();
          this.yRounder = new CoordRounder();
        }
      }, {
        key: "round",
        value: function round(x, y) {
          return {
            x: this.xRounder.round(x),
            y: this.yRounder.round(y)
          };
        }
      }]);

      return PtRounder;
    }();

    var CoordRounder = /*#__PURE__*/function () {
      function CoordRounder() {
        _classCallCheck(this, CoordRounder);

        this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON

        this.round(0);
      } // Note: this can rounds input values backwards or forwards.
      //       You might ask, why not restrict this to just rounding
      //       forwards? Wouldn't that allow left endpoints to always
      //       remain left endpoints during splitting (never change to
      //       right). No - it wouldn't, because we snap intersections
      //       to endpoints (to establish independence from the segment
      //       angle for t-intersections).


      _createClass(CoordRounder, [{
        key: "round",
        value: function round(coord) {
          var node = this.tree.add(coord);
          var prevNode = this.tree.prev(node);

          if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
            this.tree.remove(coord);
            return prevNode.key;
          }

          var nextNode = this.tree.next(node);

          if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
            this.tree.remove(coord);
            return nextNode.key;
          }

          return coord;
        }
      }]);

      return CoordRounder;
    }(); // singleton available by import


    var rounder = new PtRounder();

    /* Cross Product of two vectors with first point at origin */

    var crossProduct = function crossProduct(a, b) {
      return a.x * b.y - a.y * b.x;
    };
    /* Dot Product of two vectors with first point at origin */

    var dotProduct = function dotProduct(a, b) {
      return a.x * b.x + a.y * b.y;
    };
    /* Comparator for two vectors with same starting point */

    var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {
      var v1 = {
        x: endPt1.x - basePt.x,
        y: endPt1.y - basePt.y
      };
      var v2 = {
        x: endPt2.x - basePt.x,
        y: endPt2.y - basePt.y
      };
      var kross = crossProduct(v1, v2);
      return cmp(kross, 0);
    };
    var length = function length(v) {
      return Math.sqrt(dotProduct(v, v));
    };
    /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */

    var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {
      var vBase = {
        x: pBase.x - pShared.x,
        y: pBase.y - pShared.y
      };
      var vAngle = {
        x: pAngle.x - pShared.x,
        y: pAngle.y - pShared.y
      };
      return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
    };
    /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */

    var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {
      var vBase = {
        x: pBase.x - pShared.x,
        y: pBase.y - pShared.y
      };
      var vAngle = {
        x: pAngle.x - pShared.x,
        y: pAngle.y - pShared.y
      };
      return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
    };
    /* Get the x coordinate where the given line (defined by a point and vector)
     * crosses the horizontal line with the given y coordiante.
     * In the case of parrallel lines (including overlapping ones) returns null. */

    var horizontalIntersection = function horizontalIntersection(pt, v, y) {
      if (v.y === 0) return null;
      return {
        x: pt.x + v.x / v.y * (y - pt.y),
        y: y
      };
    };
    /* Get the y coordinate where the given line (defined by a point and vector)
     * crosses the vertical line with the given x coordiante.
     * In the case of parrallel lines (including overlapping ones) returns null. */

    var verticalIntersection = function verticalIntersection(pt, v, x) {
      if (v.x === 0) return null;
      return {
        x: x,
        y: pt.y + v.y / v.x * (x - pt.x)
      };
    };
    /* Get the intersection of two lines, each defined by a base point and a vector.
     * In the case of parrallel lines (including overlapping ones) returns null. */

    var intersection = function intersection(pt1, v1, pt2, v2) {
      // take some shortcuts for vertical and horizontal lines
      // this also ensures we don't calculate an intersection and then discover
      // it's actually outside the bounding box of the line
      if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
      if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
      if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
      if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.
      // This algorithm is based on Schneider and Eberly.
      // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244

      var kross = crossProduct(v1, v2);
      if (kross == 0) return null;
      var ve = {
        x: pt2.x - pt1.x,
        y: pt2.y - pt1.y
      };
      var d1 = crossProduct(ve, v1) / kross;
      var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error

      var x1 = pt1.x + d2 * v1.x,
          x2 = pt2.x + d1 * v2.x;
      var y1 = pt1.y + d2 * v1.y,
          y2 = pt2.y + d1 * v2.y;
      var x = (x1 + x2) / 2;
      var y = (y1 + y2) / 2;
      return {
        x: x,
        y: y
      };
    };

    var SweepEvent = /*#__PURE__*/function () {
      _createClass(SweepEvent, null, [{
        key: "compare",
        // for ordering sweep events in the sweep event queue
        value: function compare(a, b) {
          // favor event with a point that the sweep line hits first
          var ptCmp = SweepEvent.comparePoints(a.point, b.point);
          if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed

          if (a.point !== b.point) a.link(b); // favor right events over left

          if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints
          // ordering of this case is the same as for their segments

          return Segment.compare(a.segment, b.segment);
        } // for ordering points in sweep line order

      }, {
        key: "comparePoints",
        value: function comparePoints(aPt, bPt) {
          if (aPt.x < bPt.x) return -1;
          if (aPt.x > bPt.x) return 1;
          if (aPt.y < bPt.y) return -1;
          if (aPt.y > bPt.y) return 1;
          return 0;
        } // Warning: 'point' input will be modified and re-used (for performance)

      }]);

      function SweepEvent(point, isLeft) {
        _classCallCheck(this, SweepEvent);

        if (point.events === undefined) point.events = [this];else point.events.push(this);
        this.point = point;
        this.isLeft = isLeft; // this.segment, this.otherSE set by factory
      }

      _createClass(SweepEvent, [{
        key: "link",
        value: function link(other) {
          if (other.point === this.point) {
            throw new Error('Tried to link already linked events');
          }

          var otherEvents = other.point.events;

          for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
            var evt = otherEvents[i];
            this.point.events.push(evt);
            evt.point = this.point;
          }

          this.checkForConsuming();
        }
        /* Do a pass over our linked events and check to see if any pair
         * of segments match, and should be consumed. */

      }, {
        key: "checkForConsuming",
        value: function checkForConsuming() {
          // FIXME: The loops in this method run O(n^2) => no good.
          //        Maintain little ordered sweep event trees?
          //        Can we maintaining an ordering that avoids the need
          //        for the re-sorting with getLeftmostComparator in geom-out?
          // Compare each pair of events to see if other events also match
          var numEvents = this.point.events.length;

          for (var i = 0; i < numEvents; i++) {
            var evt1 = this.point.events[i];
            if (evt1.segment.consumedBy !== undefined) continue;

            for (var j = i + 1; j < numEvents; j++) {
              var evt2 = this.point.events[j];
              if (evt2.consumedBy !== undefined) continue;
              if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
              evt1.segment.consume(evt2.segment);
            }
          }
        }
      }, {
        key: "getAvailableLinkedEvents",
        value: function getAvailableLinkedEvents() {
          // point.events is always of length 2 or greater
          var events = [];

          for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
            var evt = this.point.events[i];

            if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
              events.push(evt);
            }
          }

          return events;
        }
        /**
         * Returns a comparator function for sorting linked events that will
         * favor the event that will give us the smallest left-side angle.
         * All ring construction starts as low as possible heading to the right,
         * so by always turning left as sharp as possible we'll get polygons
         * without uncessary loops & holes.
         *
         * The comparator function has a compute cache such that it avoids
         * re-computing already-computed values.
         */

      }, {
        key: "getLeftmostComparator",
        value: function getLeftmostComparator(baseEvent) {
          var _this = this;

          var cache = new Map();

          var fillCache = function fillCache(linkedEvent) {
            var nextEvent = linkedEvent.otherSE;
            cache.set(linkedEvent, {
              sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
              cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
            });
          };

          return function (a, b) {
            if (!cache.has(a)) fillCache(a);
            if (!cache.has(b)) fillCache(b);

            var _cache$get = cache.get(a),
                asine = _cache$get.sine,
                acosine = _cache$get.cosine;

            var _cache$get2 = cache.get(b),
                bsine = _cache$get2.sine,
                bcosine = _cache$get2.cosine; // both on or above x-axis


            if (asine >= 0 && bsine >= 0) {
              if (acosine < bcosine) return 1;
              if (acosine > bcosine) return -1;
              return 0;
            } // both below x-axis


            if (asine < 0 && bsine < 0) {
              if (acosine < bcosine) return -1;
              if (acosine > bcosine) return 1;
              return 0;
            } // one above x-axis, one below


            if (bsine < asine) return -1;
            if (bsine > asine) return 1;
            return 0;
          };
        }
      }]);

      return SweepEvent;
    }();

    // segments and sweep events when all else is identical

    var segmentId = 0;

    var Segment = /*#__PURE__*/function () {
      _createClass(Segment, null, [{
        key: "compare",

        /* This compare() function is for ordering segments in the sweep
         * line tree, and does so according to the following criteria:
         *
         * Consider the vertical line that lies an infinestimal step to the
         * right of the right-more of the two left endpoints of the input
         * segments. Imagine slowly moving a point up from negative infinity
         * in the increasing y direction. Which of the two segments will that
         * point intersect first? That segment comes 'before' the other one.
         *
         * If neither segment would be intersected by such a line, (if one
         * or more of the segments are vertical) then the line to be considered
         * is directly on the right-more of the two left inputs.
         */
        value: function compare(a, b) {
          var alx = a.leftSE.point.x;
          var blx = b.leftSE.point.x;
          var arx = a.rightSE.point.x;
          var brx = b.rightSE.point.x; // check if they're even in the same vertical plane

          if (brx < alx) return 1;
          if (arx < blx) return -1;
          var aly = a.leftSE.point.y;
          var bly = b.leftSE.point.y;
          var ary = a.rightSE.point.y;
          var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?

          if (alx < blx) {
            // are the two segments in the same horizontal plane?
            if (bly < aly && bly < ary) return 1;
            if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?

            var aCmpBLeft = a.comparePoint(b.leftSE.point);
            if (aCmpBLeft < 0) return 1;
            if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?

            var bCmpARight = b.comparePoint(a.rightSE.point);
            if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more
            // left endpoint to be first (arbitrary?)

            return -1;
          } // is left endpoint of segment A the right-more?


          if (alx > blx) {
            if (aly < bly && aly < bry) return -1;
            if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?

            var bCmpALeft = b.comparePoint(a.leftSE.point);
            if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?

            var aCmpBRight = a.comparePoint(b.rightSE.point);
            if (aCmpBRight < 0) return 1;
            if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more
            // left endpoint to be first (arbitrary?)

            return 1;
          } // if we get here, the two left endpoints are in the same
          // vertical plane, ie alx === blx
          // consider the lower left-endpoint to come first


          if (aly < bly) return -1;
          if (aly > bly) return 1; // left endpoints are identical
          // check for colinearity by using the left-more right endpoint
          // is the A right endpoint more left-more?

          if (arx < brx) {
            var _bCmpARight = b.comparePoint(a.rightSE.point);

            if (_bCmpARight !== 0) return _bCmpARight;
          } // is the B right endpoint more left-more?


          if (arx > brx) {
            var _aCmpBRight = a.comparePoint(b.rightSE.point);

            if (_aCmpBRight < 0) return 1;
            if (_aCmpBRight > 0) return -1;
          }

          if (arx !== brx) {
            // are these two [almost] vertical segments with opposite orientation?
            // if so, the one with the lower right endpoint comes first
            var ay = ary - aly;
            var ax = arx - alx;
            var by = bry - bly;
            var bx = brx - blx;
            if (ay > ax && by < bx) return 1;
            if (ay < ax && by > bx) return -1;
          } // we have colinear segments with matching orientation
          // consider the one with more left-more right endpoint to be first


          if (arx > brx) return 1;
          if (arx < brx) return -1; // if we get here, two two right endpoints are in the same
          // vertical plane, ie arx === brx
          // consider the lower right-endpoint to come first

          if (ary < bry) return -1;
          if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential
          // fall back on creation order as consistent tie-breaker

          if (a.id < b.id) return -1;
          if (a.id > b.id) return 1; // identical segment, ie a === b

          return 0;
        }
        /* Warning: a reference to ringWindings input will be stored,
         *  and possibly will be later modified */

      }]);

      function Segment(leftSE, rightSE, rings, windings) {
        _classCallCheck(this, Segment);

        this.id = ++segmentId;
        this.leftSE = leftSE;
        leftSE.segment = this;
        leftSE.otherSE = rightSE;
        this.rightSE = rightSE;
        rightSE.segment = this;
        rightSE.otherSE = leftSE;
        this.rings = rings;
        this.windings = windings; // left unset for performance, set later in algorithm
        // this.ringOut, this.consumedBy, this.prev
      }

      _createClass(Segment, [{
        key: "replaceRightSE",

        /* When a segment is split, the rightSE is replaced with a new sweep event */
        value: function replaceRightSE(newRightSE) {
          this.rightSE = newRightSE;
          this.rightSE.segment = this;
          this.rightSE.otherSE = this.leftSE;
          this.leftSE.otherSE = this.rightSE;
        }
      }, {
        key: "bbox",
        value: function bbox() {
          var y1 = this.leftSE.point.y;
          var y2 = this.rightSE.point.y;
          return {
            ll: {
              x: this.leftSE.point.x,
              y: y1 < y2 ? y1 : y2
            },
            ur: {
              x: this.rightSE.point.x,
              y: y1 > y2 ? y1 : y2
            }
          };
        }
        /* A vector from the left point to the right */

      }, {
        key: "vector",
        value: function vector() {
          return {
            x: this.rightSE.point.x - this.leftSE.point.x,
            y: this.rightSE.point.y - this.leftSE.point.y
          };
        }
      }, {
        key: "isAnEndpoint",
        value: function isAnEndpoint(pt) {
          return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
        }
        /* Compare this segment with a point.
         *
         * A point P is considered to be colinear to a segment if there
         * exists a distance D such that if we travel along the segment
         * from one * endpoint towards the other a distance D, we find
         * ourselves at point P.
         *
         * Return value indicates:
         *
         *   1: point lies above the segment (to the left of vertical)
         *   0: point is colinear to segment
         *  -1: point lies below the segment (to the right of vertical)
         */

      }, {
        key: "comparePoint",
        value: function comparePoint(point) {
          if (this.isAnEndpoint(point)) return 0;
          var lPt = this.leftSE.point;
          var rPt = this.rightSE.point;
          var v = this.vector(); // Exactly vertical segments.

          if (lPt.x === rPt.x) {
            if (point.x === lPt.x) return 0;
            return point.x < lPt.x ? 1 : -1;
          } // Nearly vertical segments with an intersection.
          // Check to see where a point on the line with matching Y coordinate is.


          var yDist = (point.y - lPt.y) / v.y;
          var xFromYDist = lPt.x + yDist * v.x;
          if (point.x === xFromYDist) return 0; // General case.
          // Check to see where a point on the line with matching X coordinate is.

          var xDist = (point.x - lPt.x) / v.x;
          var yFromXDist = lPt.y + xDist * v.y;
          if (point.y === yFromXDist) return 0;
          return point.y < yFromXDist ? -1 : 1;
        }
        /**
         * Given another segment, returns the first non-trivial intersection
         * between the two segments (in terms of sweep line ordering), if it exists.
         *
         * A 'non-trivial' intersection is one that will cause one or both of the
         * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
         *
         *   * endpoint of segA with endpoint of segB --> trivial
         *   * endpoint of segA with point along segB --> non-trivial
         *   * endpoint of segB with point along segA --> non-trivial
         *   * point along segA with point along segB --> non-trivial
         *
         * If no non-trivial intersection exists, return null
         * Else, return null.
         */

      }, {
        key: "getIntersection",
        value: function getIntersection(other) {
          // If bboxes don't overlap, there can't be any intersections
          var tBbox = this.bbox();
          var oBbox = other.bbox();
          var bboxOverlap = getBboxOverlap(tBbox, oBbox);
          if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.
          // This will 'snap' intersections to endpoints if possible, and will
          // handle cases of colinearity.

          var tlp = this.leftSE.point;
          var trp = this.rightSE.point;
          var olp = other.leftSE.point;
          var orp = other.rightSE.point; // does each endpoint touch the other segment?
          // note that we restrict the 'touching' definition to only allow segments
          // to touch endpoints that lie forward from where we are in the sweep line pass

          var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
          var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
          var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
          var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?

          if (touchesThisLSE && touchesOtherLSE) {
            // these two cases are for colinear segments with matching left
            // endpoints, and one segment being longer than the other
            if (touchesThisRSE && !touchesOtherRSE) return trp;
            if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)
            // or just on their left endpoint (one trivial intersection

            return null;
          } // does this left endpoint matches (other doesn't)


          if (touchesThisLSE) {
            // check for segments that just intersect on opposing endpoints
            if (touchesOtherRSE) {
              if (tlp.x === orp.x && tlp.y === orp.y) return null;
            } // t-intersection on left endpoint


            return tlp;
          } // does other left endpoint matches (this doesn't)


          if (touchesOtherLSE) {
            // check for segments that just intersect on opposing endpoints
            if (touchesThisRSE) {
              if (trp.x === olp.x && trp.y === olp.y) return null;
            } // t-intersection on left endpoint


            return olp;
          } // trivial intersection on right endpoints


          if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint

          if (touchesThisRSE) return trp;
          if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between
          // infinite lines laid over the segments

          var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,
          // they would have an endpoint intersection and that case was already handled above

          if (pt === null) return null; // is the intersection found between the lines not on the segments?

          if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed

          return rounder.round(pt.x, pt.y);
        }
        /**
         * Split the given segment into multiple segments on the given points.
         *  * Each existing segment will retain its leftSE and a new rightSE will be
         *    generated for it.
         *  * A new segment will be generated which will adopt the original segment's
         *    rightSE, and a new leftSE will be generated for it.
         *  * If there are more than two points given to split on, new segments
         *    in the middle will be generated with new leftSE and rightSE's.
         *  * An array of the newly generated SweepEvents will be returned.
         *
         * Warning: input array of points is modified
         */

      }, {
        key: "split",
        value: function split(point) {
          var newEvents = [];
          var alreadyLinked = point.events !== undefined;
          var newLeftSE = new SweepEvent(point, true);
          var newRightSE = new SweepEvent(point, false);
          var oldRightSE = this.rightSE;
          this.replaceRightSE(newRightSE);
          newEvents.push(newRightSE);
          newEvents.push(newLeftSE);
          var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,
          // sometimes one of the resulting new segments is vertical, in which
          // case its left and right events may need to be swapped

          if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
            newSeg.swapEvents();
          }

          if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
            this.swapEvents();
          } // in the point we just used to create new sweep events with was already
          // linked to other events, we need to check if either of the affected
          // segments should be consumed


          if (alreadyLinked) {
            newLeftSE.checkForConsuming();
            newRightSE.checkForConsuming();
          }

          return newEvents;
        }
        /* Swap which event is left and right */

      }, {
        key: "swapEvents",
        value: function swapEvents() {
          var tmpEvt = this.rightSE;
          this.rightSE = this.leftSE;
          this.leftSE = tmpEvt;
          this.leftSE.isLeft = true;
          this.rightSE.isLeft = false;

          for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
            this.windings[i] *= -1;
          }
        }
        /* Consume another segment. We take their rings under our wing
         * and mark them as consumed. Use for perfectly overlapping segments */

      }, {
        key: "consume",
        value: function consume(other) {
          var consumer = this;
          var consumee = other;

          while (consumer.consumedBy) {
            consumer = consumer.consumedBy;
          }

          while (consumee.consumedBy) {
            consumee = consumee.consumedBy;
          }

          var cmp = Segment.compare(consumer, consumee);
          if (cmp === 0) return; // already consumed
          // the winner of the consumption is the earlier segment
          // according to sweep line ordering

          if (cmp > 0) {
            var tmp = consumer;
            consumer = consumee;
            consumee = tmp;
          } // make sure a segment doesn't consume it's prev


          if (consumer.prev === consumee) {
            var _tmp = consumer;
            consumer = consumee;
            consumee = _tmp;
          }

          for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
            var ring = consumee.rings[i];
            var winding = consumee.windings[i];
            var index = consumer.rings.indexOf(ring);

            if (index === -1) {
              consumer.rings.push(ring);
              consumer.windings.push(winding);
            } else consumer.windings[index] += winding;
          }

          consumee.rings = null;
          consumee.windings = null;
          consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue

          consumee.leftSE.consumedBy = consumer.leftSE;
          consumee.rightSE.consumedBy = consumer.rightSE;
        }
        /* The first segment previous segment chain that is in the result */

      }, {
        key: "prevInResult",
        value: function prevInResult() {
          if (this._prevInResult !== undefined) return this._prevInResult;
          if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();
          return this._prevInResult;
        }
      }, {
        key: "beforeState",
        value: function beforeState() {
          if (this._beforeState !== undefined) return this._beforeState;
          if (!this.prev) this._beforeState = {
            rings: [],
            windings: [],
            multiPolys: []
          };else {
            var seg = this.prev.consumedBy || this.prev;
            this._beforeState = seg.afterState();
          }
          return this._beforeState;
        }
      }, {
        key: "afterState",
        value: function afterState() {
          if (this._afterState !== undefined) return this._afterState;
          var beforeState = this.beforeState();
          this._afterState = {
            rings: beforeState.rings.slice(0),
            windings: beforeState.windings.slice(0),
            multiPolys: []
          };
          var ringsAfter = this._afterState.rings;
          var windingsAfter = this._afterState.windings;
          var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter

          for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
            var ring = this.rings[i];
            var winding = this.windings[i];
            var index = ringsAfter.indexOf(ring);

            if (index === -1) {
              ringsAfter.push(ring);
              windingsAfter.push(winding);
            } else windingsAfter[index] += winding;
          } // calcualte polysAfter


          var polysAfter = [];
          var polysExclude = [];

          for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
            if (windingsAfter[_i] === 0) continue; // non-zero rule

            var _ring = ringsAfter[_i];
            var poly = _ring.poly;
            if (polysExclude.indexOf(poly) !== -1) continue;
            if (_ring.isExterior) polysAfter.push(poly);else {
              if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);

              var _index = polysAfter.indexOf(_ring.poly);

              if (_index !== -1) polysAfter.splice(_index, 1);
            }
          } // calculate multiPolysAfter


          for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
            var mp = polysAfter[_i2].multiPoly;
            if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
          }

          return this._afterState;
        }
        /* Is this segment part of the final result? */

      }, {
        key: "isInResult",
        value: function isInResult() {
          // if we've been consumed, we're not in the result
          if (this.consumedBy) return false;
          if (this._isInResult !== undefined) return this._isInResult;
          var mpsBefore = this.beforeState().multiPolys;
          var mpsAfter = this.afterState().multiPolys;

          switch (operation.type) {
            case 'union':
              {
                // UNION - included iff:
                //  * On one side of us there is 0 poly interiors AND
                //  * On the other side there is 1 or more.
                var noBefores = mpsBefore.length === 0;
                var noAfters = mpsAfter.length === 0;
                this._isInResult = noBefores !== noAfters;
                break;
              }

            case 'intersection':
              {
                // INTERSECTION - included iff:
                //  * on one side of us all multipolys are rep. with poly interiors AND
                //  * on the other side of us, not all multipolys are repsented
                //    with poly interiors
                var least;
                var most;

                if (mpsBefore.length < mpsAfter.length) {
                  least = mpsBefore.length;
                  most = mpsAfter.length;
                } else {
                  least = mpsAfter.length;
                  most = mpsBefore.length;
                }

                this._isInResult = most === operation.numMultiPolys && least < most;
                break;
              }

            case 'xor':
              {
                // XOR - included iff:
                //  * the difference between the number of multipolys represented
                //    with poly interiors on our two sides is an odd number
                var diff = Math.abs(mpsBefore.length - mpsAfter.length);
                this._isInResult = diff % 2 === 1;
                break;
              }

            case 'difference':
              {
                // DIFFERENCE included iff:
                //  * on exactly one side, we have just the subject
                var isJustSubject = function isJustSubject(mps) {
                  return mps.length === 1 && mps[0].isSubject;
                };

                this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                break;
              }

            default:
              throw new Error("Unrecognized operation type found ".concat(operation.type));
          }

          return this._isInResult;
        }
      }], [{
        key: "fromRing",
        value: function fromRing(pt1, pt2, ring) {
          var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering

          var cmpPts = SweepEvent.comparePoints(pt1, pt2);

          if (cmpPts < 0) {
            leftPt = pt1;
            rightPt = pt2;
            winding = 1;
          } else if (cmpPts > 0) {
            leftPt = pt2;
            rightPt = pt1;
            winding = -1;
          } else throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));

          var leftSE = new SweepEvent(leftPt, true);
          var rightSE = new SweepEvent(rightPt, false);
          return new Segment(leftSE, rightSE, [ring], [winding]);
        }
      }]);

      return Segment;
    }();

    var RingIn = /*#__PURE__*/function () {
      function RingIn(geomRing, poly, isExterior) {
        _classCallCheck(this, RingIn);

        if (!Array.isArray(geomRing) || geomRing.length === 0) {
          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
        }

        this.poly = poly;
        this.isExterior = isExterior;
        this.segments = [];

        if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {
          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
        }

        var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
        this.bbox = {
          ll: {
            x: firstPoint.x,
            y: firstPoint.y
          },
          ur: {
            x: firstPoint.x,
            y: firstPoint.y
          }
        };
        var prevPoint = firstPoint;

        for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
          if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {
            throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
          }

          var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points

          if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
          this.segments.push(Segment.fromRing(prevPoint, point, this));
          if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
          if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
          if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
          if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
          prevPoint = point;
        } // add segment from last to first if last is not the same as first


        if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
          this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
        }
      }

      _createClass(RingIn, [{
        key: "getSweepEvents",
        value: function getSweepEvents() {
          var sweepEvents = [];

          for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
            var segment = this.segments[i];
            sweepEvents.push(segment.leftSE);
            sweepEvents.push(segment.rightSE);
          }

          return sweepEvents;
        }
      }]);

      return RingIn;
    }();
    var PolyIn = /*#__PURE__*/function () {
      function PolyIn(geomPoly, multiPoly) {
        _classCallCheck(this, PolyIn);

        if (!Array.isArray(geomPoly)) {
          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
        }

        this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value

        this.bbox = {
          ll: {
            x: this.exteriorRing.bbox.ll.x,
            y: this.exteriorRing.bbox.ll.y
          },
          ur: {
            x: this.exteriorRing.bbox.ur.x,
            y: this.exteriorRing.bbox.ur.y
          }
        };
        this.interiorRings = [];

        for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
          var ring = new RingIn(geomPoly[i], this, false);
          if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
          if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
          if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
          if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
          this.interiorRings.push(ring);
        }

        this.multiPoly = multiPoly;
      }

      _createClass(PolyIn, [{
        key: "getSweepEvents",
        value: function getSweepEvents() {
          var sweepEvents = this.exteriorRing.getSweepEvents();

          for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
            var ringSweepEvents = this.interiorRings[i].getSweepEvents();

            for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
              sweepEvents.push(ringSweepEvents[j]);
            }
          }

          return sweepEvents;
        }
      }]);

      return PolyIn;
    }();
    var MultiPolyIn = /*#__PURE__*/function () {
      function MultiPolyIn(geom, isSubject) {
        _classCallCheck(this, MultiPolyIn);

        if (!Array.isArray(geom)) {
          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
        }

        try {
          // if the input looks like a polygon, convert it to a multipolygon
          if (typeof geom[0][0][0] === 'number') geom = [geom];
        } catch (ex) {// The input is either malformed or has empty arrays.
          // In either case, it will be handled later on.
        }

        this.polys = [];
        this.bbox = {
          ll: {
            x: Number.POSITIVE_INFINITY,
            y: Number.POSITIVE_INFINITY
          },
          ur: {
            x: Number.NEGATIVE_INFINITY,
            y: Number.NEGATIVE_INFINITY
          }
        };

        for (var i = 0, iMax = geom.length; i < iMax; i++) {
          var poly = new PolyIn(geom[i], this);
          if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
          if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
          if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
          if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
          this.polys.push(poly);
        }

        this.isSubject = isSubject;
      }

      _createClass(MultiPolyIn, [{
        key: "getSweepEvents",
        value: function getSweepEvents() {
          var sweepEvents = [];

          for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
            var polySweepEvents = this.polys[i].getSweepEvents();

            for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
              sweepEvents.push(polySweepEvents[j]);
            }
          }

          return sweepEvents;
        }
      }]);

      return MultiPolyIn;
    }();

    var RingOut = /*#__PURE__*/function () {
      _createClass(RingOut, null, [{
        key: "factory",

        /* Given the segments from the sweep line pass, compute & return a series
         * of closed rings from all the segments marked to be part of the result */
        value: function factory(allSegments) {
          var ringsOut = [];

          for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
            var segment = allSegments[i];
            if (!segment.isInResult() || segment.ringOut) continue;
            var prevEvent = null;
            var event = segment.leftSE;
            var nextEvent = segment.rightSE;
            var events = [event];
            var startingPoint = event.point;
            var intersectionLEs = [];
            /* Walk the chain of linked events to form a closed ring */

            while (true) {
              prevEvent = event;
              event = nextEvent;
              events.push(event);
              /* Is the ring complete? */

              if (event.point === startingPoint) break;

              while (true) {
                var availableLEs = event.getAvailableLinkedEvents();
                /* Did we hit a dead end? This shouldn't happen. Indicates some earlier
                 * part of the algorithm malfunctioned... please file a bug report. */

                if (availableLEs.length === 0) {
                  var firstPt = events[0].point;
                  var lastPt = events[events.length - 1].point;
                  throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
                }
                /* Only one way to go, so cotinue on the path */


                if (availableLEs.length === 1) {
                  nextEvent = availableLEs[0].otherSE;
                  break;
                }
                /* We must have an intersection. Check for a completed loop */


                var indexLE = null;

                for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                  if (intersectionLEs[j].point === event.point) {
                    indexLE = j;
                    break;
                  }
                }
                /* Found a completed loop. Cut that off and make a ring */


                if (indexLE !== null) {
                  var intersectionLE = intersectionLEs.splice(indexLE)[0];
                  var ringEvents = events.splice(intersectionLE.index);
                  ringEvents.unshift(ringEvents[0].otherSE);
                  ringsOut.push(new RingOut(ringEvents.reverse()));
                  continue;
                }
                /* register the intersection */


                intersectionLEs.push({
                  index: events.length,
                  point: event.point
                });
                /* Choose the left-most option to continue the walk */

                var comparator = event.getLeftmostComparator(prevEvent);
                nextEvent = availableLEs.sort(comparator)[0].otherSE;
                break;
              }
            }

            ringsOut.push(new RingOut(events));
          }

          return ringsOut;
        }
      }]);

      function RingOut(events) {
        _classCallCheck(this, RingOut);

        this.events = events;

        for (var i = 0, iMax = events.length; i < iMax; i++) {
          events[i].segment.ringOut = this;
        }

        this.poly = null;
      }

      _createClass(RingOut, [{
        key: "getGeom",
        value: function getGeom() {
          // Remove superfluous points (ie extra points along a straight line),
          var prevPt = this.events[0].point;
          var points = [prevPt];

          for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
            var _pt = this.events[i].point;
            var _nextPt = this.events[i + 1].point;
            if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;
            points.push(_pt);
            prevPt = _pt;
          } // ring was all (within rounding error of angle calc) colinear points


          if (points.length === 1) return null; // check if the starting point is necessary

          var pt = points[0];
          var nextPt = points[1];
          if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
          points.push(points[0]);
          var step = this.isExteriorRing() ? 1 : -1;
          var iStart = this.isExteriorRing() ? 0 : points.length - 1;
          var iEnd = this.isExteriorRing() ? points.length : -1;
          var orderedPoints = [];

          for (var _i = iStart; _i != iEnd; _i += step) {
            orderedPoints.push([points[_i].x, points[_i].y]);
          }

          return orderedPoints;
        }
      }, {
        key: "isExteriorRing",
        value: function isExteriorRing() {
          if (this._isExteriorRing === undefined) {
            var enclosing = this.enclosingRing();
            this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
          }

          return this._isExteriorRing;
        }
      }, {
        key: "enclosingRing",
        value: function enclosingRing() {
          if (this._enclosingRing === undefined) {
            this._enclosingRing = this._calcEnclosingRing();
          }

          return this._enclosingRing;
        }
        /* Returns the ring that encloses this one, if any */

      }, {
        key: "_calcEnclosingRing",
        value: function _calcEnclosingRing() {
          // start with the ealier sweep line event so that the prevSeg
          // chain doesn't lead us inside of a loop of ours
          var leftMostEvt = this.events[0];

          for (var i = 1, iMax = this.events.length; i < iMax; i++) {
            var evt = this.events[i];
            if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
          }

          var prevSeg = leftMostEvt.segment.prevInResult();
          var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;

          while (true) {
            // no segment found, thus no ring can enclose us
            if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev
            // segment must loop back around and enclose us

            if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev
            // segment must either loop around us or the ring of the prev prev
            // seg, which would make us and the ring of the prev peers

            if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
              if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
                return prevSeg.ringOut;
              } else return prevSeg.ringOut.enclosingRing();
            } // two segments are from the same ring, so this was a penisula
            // of that ring. iterate downward, keep searching


            prevSeg = prevPrevSeg.prevInResult();
            prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
          }
        }
      }]);

      return RingOut;
    }();
    var PolyOut = /*#__PURE__*/function () {
      function PolyOut(exteriorRing) {
        _classCallCheck(this, PolyOut);

        this.exteriorRing = exteriorRing;
        exteriorRing.poly = this;
        this.interiorRings = [];
      }

      _createClass(PolyOut, [{
        key: "addInterior",
        value: function addInterior(ring) {
          this.interiorRings.push(ring);
          ring.poly = this;
        }
      }, {
        key: "getGeom",
        value: function getGeom() {
          var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points

          if (geom[0] === null) return null;

          for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
            var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points

            if (ringGeom === null) continue;
            geom.push(ringGeom);
          }

          return geom;
        }
      }]);

      return PolyOut;
    }();
    var MultiPolyOut = /*#__PURE__*/function () {
      function MultiPolyOut(rings) {
        _classCallCheck(this, MultiPolyOut);

        this.rings = rings;
        this.polys = this._composePolys(rings);
      }

      _createClass(MultiPolyOut, [{
        key: "getGeom",
        value: function getGeom() {
          var geom = [];

          for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
            var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points

            if (polyGeom === null) continue;
            geom.push(polyGeom);
          }

          return geom;
        }
      }, {
        key: "_composePolys",
        value: function _composePolys(rings) {
          var polys = [];

          for (var i = 0, iMax = rings.length; i < iMax; i++) {
            var ring = rings[i];
            if (ring.poly) continue;
            if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {
              var enclosingRing = ring.enclosingRing();
              if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
              enclosingRing.poly.addInterior(ring);
            }
          }

          return polys;
        }
      }]);

      return MultiPolyOut;
    }();

    /**
     * NOTE:  We must be careful not to change any segments while
     *        they are in the SplayTree. AFAIK, there's no way to tell
     *        the tree to rebalance itself - thus before splitting
     *        a segment that's in the tree, we remove it from the tree,
     *        do the split, then re-insert it. (Even though splitting a
     *        segment *shouldn't* change its correct position in the
     *        sweep line tree, the reality is because of rounding errors,
     *        it sometimes does.)
     */

    var SweepLine = /*#__PURE__*/function () {
      function SweepLine(queue) {
        var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;

        _classCallCheck(this, SweepLine);

        this.queue = queue;
        this.tree = new Tree(comparator);
        this.segments = [];
      }

      _createClass(SweepLine, [{
        key: "process",
        value: function process(event) {
          var segment = event.segment;
          var newEvents = []; // if we've already been consumed by another segment,
          // clean up our body parts and get out

          if (event.consumedBy) {
            if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);
            return newEvents;
          }

          var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
          if (!node) throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + 'in SweepLine tree. Please submit a bug report.');
          var prevNode = node;
          var nextNode = node;
          var prevSeg = undefined;
          var nextSeg = undefined; // skip consumed segments still in tree

          while (prevSeg === undefined) {
            prevNode = this.tree.prev(prevNode);
            if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;
          } // skip consumed segments still in tree


          while (nextSeg === undefined) {
            nextNode = this.tree.next(nextNode);
            if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;
          }

          if (event.isLeft) {
            // Check for intersections against the previous segment in the sweep line
            var prevMySplitter = null;

            if (prevSeg) {
              var prevInter = prevSeg.getIntersection(segment);

              if (prevInter !== null) {
                if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;

                if (!prevSeg.isAnEndpoint(prevInter)) {
                  var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);

                  for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                    newEvents.push(newEventsFromSplit[i]);
                  }
                }
              }
            } // Check for intersections against the next segment in the sweep line


            var nextMySplitter = null;

            if (nextSeg) {
              var nextInter = nextSeg.getIntersection(segment);

              if (nextInter !== null) {
                if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;

                if (!nextSeg.isAnEndpoint(nextInter)) {
                  var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);

                  for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                    newEvents.push(_newEventsFromSplit[_i]);
                  }
                }
              }
            } // For simplicity, even if we find more than one intersection we only
            // spilt on the 'earliest' (sweep-line style) of the intersections.
            // The other intersection will be handled in a future process().


            if (prevMySplitter !== null || nextMySplitter !== null) {
              var mySplitter = null;
              if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {
                var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
              } // Rounding errors can cause changes in ordering,
              // so remove afected segments and right sweep events before splitting

              this.queue.remove(segment.rightSE);
              newEvents.push(segment.rightSE);

              var _newEventsFromSplit2 = segment.split(mySplitter);

              for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
                newEvents.push(_newEventsFromSplit2[_i2]);
              }
            }

            if (newEvents.length > 0) {
              // We found some intersections, so re-do the current event to
              // make sure sweep line ordering is totally consistent for later
              // use with the segment 'prev' pointers
              this.tree.remove(segment);
              newEvents.push(event);
            } else {
              // done with left event
              this.segments.push(segment);
              segment.prev = prevSeg;
            }
          } else {
            // event.isRight
            // since we're about to be removed from the sweep line, check for
            // intersections between our previous and next segments
            if (prevSeg && nextSeg) {
              var inter = prevSeg.getIntersection(nextSeg);

              if (inter !== null) {
                if (!prevSeg.isAnEndpoint(inter)) {
                  var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);

                  for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                    newEvents.push(_newEventsFromSplit3[_i3]);
                  }
                }

                if (!nextSeg.isAnEndpoint(inter)) {
                  var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);

                  for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                    newEvents.push(_newEventsFromSplit4[_i4]);
                  }
                }
              }
            }

            this.tree.remove(segment);
          }

          return newEvents;
        }
        /* Safely split a segment that is currently in the datastructures
         * IE - a segment other than the one that is currently being processed. */

      }, {
        key: "_splitSafely",
        value: function _splitSafely(seg, pt) {
          // Rounding errors can cause changes in ordering,
          // so remove afected segments and right sweep events before splitting
          // removeNode() doesn't work, so have re-find the seg
          // https://github.com/w8r/splay-tree/pull/5
          this.tree.remove(seg);
          var rightSE = seg.rightSE;
          this.queue.remove(rightSE);
          var newEvents = seg.split(pt);
          newEvents.push(rightSE); // splitting can trigger consumption

          if (seg.consumedBy === undefined) this.tree.insert(seg);
          return newEvents;
        }
      }]);

      return SweepLine;
    }();

    var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;
    var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;
    var Operation = /*#__PURE__*/function () {
      function Operation() {
        _classCallCheck(this, Operation);
      }

      _createClass(Operation, [{
        key: "run",
        value: function run(type, geom, moreGeoms) {
          operation.type = type;
          rounder.reset();
          /* Convert inputs to MultiPoly objects */

          var multipolys = [new MultiPolyIn(geom, true)];

          for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
            multipolys.push(new MultiPolyIn(moreGeoms[i], false));
          }

          operation.numMultiPolys = multipolys.length;
          /* BBox optimization for difference operation
           * If the bbox of a multipolygon that's part of the clipping doesn't
           * intersect the bbox of the subject at all, we can just drop that
           * multiploygon. */

          if (operation.type === 'difference') {
            // in place removal
            var subject = multipolys[0];
            var _i = 1;

            while (_i < multipolys.length) {
              if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);
            }
          }
          /* BBox optimization for intersection operation
           * If we can find any pair of multipolygons whose bbox does not overlap,
           * then the result will be empty. */


          if (operation.type === 'intersection') {
            // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,
            //       it could be optimized to O(n * ln(n))
            for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
              var mpA = multipolys[_i2];

              for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
                if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
              }
            }
          }
          /* Put segment endpoints in a priority queue */


          var queue = new Tree(SweepEvent.compare);

          for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
            var sweepEvents = multipolys[_i3].getSweepEvents();

            for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
              queue.insert(sweepEvents[_j]);

              if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                // prevents an infinite loop, an otherwise common manifestation of bugs
                throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');
              }
            }
          }
          /* Pass the sweep line over those endpoints */


          var sweepLine = new SweepLine(queue);
          var prevQueueSize = queue.size;
          var node = queue.pop();

          while (node) {
            var evt = node.key;

            if (queue.size === prevQueueSize) {
              // prevents an infinite loop, an otherwise common manifestation of bugs
              var seg = evt.segment;
              throw new Error("Unable to pop() ".concat(evt.isLeft ? 'left' : 'right', " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + 'Please file a bug report.');
            }

            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
              // prevents an infinite loop, an otherwise common manifestation of bugs
              throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');
            }

            if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
              // prevents an infinite loop, an otherwise common manifestation of bugs
              throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');
            }

            var newEvents = sweepLine.process(evt);

            for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
              var _evt = newEvents[_i4];
              if (_evt.consumedBy === undefined) queue.insert(_evt);
            }

            prevQueueSize = queue.size;
            node = queue.pop();
          } // free some memory we don't need anymore


          rounder.reset();
          /* Collect and compile segments we're keeping into a multipolygon */

          var ringsOut = RingOut.factory(sweepLine.segments);
          var result = new MultiPolyOut(ringsOut);
          return result.getGeom();
        }
      }]);

      return Operation;
    }(); // singleton available by import

    var operation = new Operation();

    var union = function union(geom) {
      for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        moreGeoms[_key - 1] = arguments[_key];
      }

      return operation.run('union', geom, moreGeoms);
    };

    var intersection$1 = function intersection(geom) {
      for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        moreGeoms[_key2 - 1] = arguments[_key2];
      }

      return operation.run('intersection', geom, moreGeoms);
    };

    var xor = function xor(geom) {
      for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        moreGeoms[_key3 - 1] = arguments[_key3];
      }

      return operation.run('xor', geom, moreGeoms);
    };

    var difference = function difference(subjectGeom) {
      for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        clippingGeoms[_key4 - 1] = arguments[_key4];
      }

      return operation.run('difference', subjectGeom, clippingGeoms);
    };

    var index = {
      union: union,
      intersection: intersection$1,
      xor: xor,
      difference: difference
    };

    const poly = index;
    class MapInterface {
        constructor(config) {
            this.cache = {};
            this.config = config;
            this.api = new STAInterface(config.baseUrl);
        }
        /**
         * Converts the longitude to a OSM tile number
         * @param lon longitude
         * @param zoom current zoom level
         * @returns OSM tile number
         */
        long2tile(lon, zoom) {
            return (Math.floor((lon + 180) / 360 * Math.pow(2, zoom)));
        }
        /**
         * Converts the latitude to a OSM tile number
         * @param lat latitude
         * @param zoom current zoom level
         * @returns OSM tile number
         */
        lat2tile(lat, zoom) {
            return (Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)));
        }
        /**
         * OSM tile number to the upper left longitude
         * @param x osm tile number
         * @param z osm tile number
         * @returns longitude of upper right point of the OSM tile
         */
        tile2long(x, z) {
            return (x / Math.pow(2, z) * 360 - 180);
        }
        /**
         * OSM tile number to the upper left latitude
         * @param x osm tile number
         * @param z osm tile number
         * @returns latitude of upper right point of the OSM tile
         */
        tile2lat(y, z) {
            var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
            return (180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))));
        }
        /**
         * Converts latitude and longitude coordinates to the upper left point of the OSM tile the point intersects with
         * @param coordinate object of latitude and longitude coordinates of a point. For example: {lat, lng}
         * @param zoom current zoom level
         * @returns object with latitude and longitude of the OSM tile's upper left corner
         */
        coordinatesToOsm(coordinate, zoom) {
            var lat = this.tile2long(this.long2tile(coordinate.lat, zoom), zoom);
            var lng = this.tile2lat(this.lat2tile(coordinate.lng, zoom), zoom);
            return {
                lat,
                lng
            };
        }
        /**
        * Converts latitude and longitude coordinates to the bottom right point of the OSM tile the point intersects with
        * @param coordinate object of latitude and longitude coordinates of a point. For example: {lat, lng}
        * @param zoom current zoom level
        * @returns object with latitude and longitude of the OSM tile's bottom right corner
        */
        coordinatesToOsmBottom(coordinate, zoom) {
            var lat = this.tile2long(this.long2tile(coordinate.lat, zoom) + 1, zoom);
            var lng = this.tile2lat(this.lat2tile(coordinate.lng, zoom) + 1, zoom);
            return {
                lat,
                lng
            };
        }
        /**
         * Converts the bounding box of the map's view to the bounding box of the OSM tiles the map's bounding box intersects with
         * @param zoomLevel the current zoom level
         * @param boundingBox map's view's bounding box [topLat, topLong, bottomLat, bottomLong]
         * @returns the bounding box of the OSM tiles the map's bounding box intersects with
         */
        getOSMBoundingBox(zoomLevel, boundingBox) {
            var topleft = {
                lat: 0,
                lng: 0
            };
            var bottomright = {
                lat: 0,
                lng: 0
            };
            var latTop = this.long2tile(boundingBox[0], zoomLevel);
            var longTop = this.lat2tile(boundingBox[1], zoomLevel);
            topleft.lat = this.tile2long(latTop + 1, zoomLevel);
            topleft.lng = this.tile2lat(longTop, zoomLevel);
            var latBottom = this.long2tile(boundingBox[2], zoomLevel);
            var longBottom = this.lat2tile(boundingBox[3], zoomLevel);
            //Getting the bottom right corner of the tile
            bottomright.lat = this.tile2long(latBottom, zoomLevel);
            bottomright.lng = this.tile2lat(longBottom + 1, zoomLevel);
            return [topleft.lat, topleft.lng, bottomright.lat, bottomright.lng];
        }
        /**
         * Gets a GeoJSON from the current zoom level and bounding box, the fetched data is cached
         * @param zoom current zoom level
         * @param boundingBox map's bounding box
         * @returns a GeoJSON with polygons as clusters with the property count as the count of things inside the cluster, but only if the things are points. If not the thing's location is returned.
         */
        getLayerData(zoom, boundingBox) {
            return __awaiter(this, void 0, void 0, function* () {
                //Removing the reference to config.queryObject 
                var correctedQuery = JSON.parse(JSON.stringify(this.config.queryObject));
                //Checking if the queried entityType is things
                if (correctedQuery.entityType == 'Things') {
                    correctedQuery.select = ['id'];
                    correctedQuery.expand = [{
                            entityType: "Locations"
                        }];
                }
                else {
                    if (correctedQuery.entityType == 'FeaturesOfInterest') {
                        //If it is a FeaturesOfInterest
                        correctedQuery.select = ['feature'];
                    }
                    else {
                        throw new Error("Only Things and FeaturesOfInterest are supported");
                    }
                }
                if (this.config.cluster || this.config.cluster == undefined) {
                    //Add an object to the cache, if it is the first time for this zoom level
                    if (!this.cache[zoom]) {
                        this.cache[zoom] = {
                            "type": "FeatureCollection",
                            "features": []
                        };
                    }
                    //Only query the count not the data
                    correctedQuery.count = true;
                    correctedQuery.top = 0;
                    //Get the coordinates of the top left and bottom right
                    var top = { lat: this.lat2tile(boundingBox[1], zoom), lng: this.long2tile(boundingBox[0], zoom) };
                    var bottom = { lat: this.lat2tile(boundingBox[3], zoom), lng: this.long2tile(boundingBox[2], zoom) };
                    var recs = [];
                    //Iterate all OSM tiles
                    for (var x = bottom.lng; x <= top.lng; x++) {
                        for (var y = top.lat; y <= bottom.lat; y++) {
                            //Get top and bottom coordinates
                            var t = { lat: this.tile2lat(y, zoom), lng: this.tile2long(x, zoom) };
                            var b = { lat: this.tile2lat(y + 1, zoom), lng: this.tile2long(x + 1, zoom) };
                            //Clone the query object
                            var copyQuery = JSON.parse(JSON.stringify(correctedQuery));
                            //Get the ST filter
                            var geoFilter = polygonToFilter([
                                [
                                    [t.lng, t.lat],
                                    [t.lng, b.lat],
                                    [b.lng, b.lat],
                                    [b.lng, t.lat],
                                    [t.lng, t.lat]
                                ]
                            ], copyQuery.entityType);
                            //Append it to old filter if given
                            if (copyQuery.filter) {
                                copyQuery.filter = `(${copyQuery.filter}) and ${geoFilter}`;
                            }
                            else {
                                copyQuery.filter = geoFilter;
                            }
                            //Create a geojson polygon with tbe given coordinates
                            var feature = {
                                "type": "Feature",
                                "geometry": {
                                    "type": "Polygon",
                                    "coordinates": [
                                        [
                                            [t.lng, t.lat],
                                            [t.lng, b.lat],
                                            [b.lng, b.lat],
                                            [b.lng, t.lat],
                                            [t.lng, t.lat]
                                        ]
                                    ]
                                },
                                "properties": {
                                    "count": 0
                                }
                            };
                            //Check if a polygon is already present
                            var existing = this.cache[zoom].features.find((feature2) => {
                                return compare_features(feature, feature2);
                            });
                            if (!existing) {
                                //Query the count of things
                                var data = yield this.api.getGeoJson(copyQuery);
                                //Add it to the recs array if more than 0
                                if (data["@iot.count"] != 0) {
                                    feature.properties.count = data["@iot.count"];
                                    recs.push(feature);
                                }
                            }
                        }
                    }
                    var toMarker = [];
                    var toPush = [];
                    //Iterate all polygons
                    recs.forEach((feature) => {
                        //Check if markers should be loaded
                        if (feature.properties.count <= this.config.clusterMin) {
                            toMarker.push(feature.geometry.coordinates);
                        }
                        else {
                            toPush.push(feature);
                        }
                    });
                    this.cache[zoom].features.push(...toPush);
                    //Load markers
                    yield this.getMarkers(toMarker, zoom);
                }
                else {
                    //Get the OSM tiles bounding box
                    var OSMBOundingBox = this.getOSMBoundingBox(zoom, boundingBox);
                    var topLat = OSMBOundingBox[0];
                    var topLong = OSMBOundingBox[1];
                    var bottomLat = OSMBOundingBox[2];
                    var bottomLong = OSMBOundingBox[3];
                    geoFilter = null;
                    //Check if cached tiles exist
                    if (this.cache[zoom]) {
                        //Create a poly out of the bounding box
                        var poly1 = [
                            [
                                [topLat, topLong],
                                [topLat, bottomLong],
                                [bottomLat, bottomLong],
                                [bottomLat, topLong],
                                [topLat, topLong]
                            ]
                        ];
                        //Get all cluster tiles
                        var onlyPolys = this.cache[zoom].features.filter((geo) => {
                            var _a;
                            return (_a = geo === null || geo === void 0 ? void 0 : geo.properties) === null || _a === void 0 ? void 0 : _a.count;
                        });
                        //Get all the coordinates
                        onlyPolys = onlyPolys.map((geo) => {
                            return geo.geometry.coordinates;
                        });
                        //Subtract the cached tiles from the OSM bounding box to reduce network traffic
                        var subtracted = poly.difference(poly1, ...onlyPolys);
                        //Check if the array isn't empty
                        if (subtracted[0]) {
                            //Get the geo filter
                            geoFilter = polygonToFilter(subtracted, correctedQuery.entityType);
                        }
                        else
                            //If the array is empty, nothing has to be fetched from the server, so the cached geoJSON can be returned
                            return this.cache[zoom];
                    }
                    else {
                        //Create a polygon with the OSM bounding box coordinates
                        geoFilter = `geo.intersects(${correctedQuery.entityType == 'Things' ? 'Locations/location' : 'feature'},geography'POLYGON ((${topLat} ${topLong}, ${topLat} ${bottomLong}, ${bottomLat} ${bottomLong}, ${bottomLat} ${topLong} ,${topLat} ${topLong}))')`;
                    }
                    //Check for an existing filter
                    if (correctedQuery.filter) {
                        correctedQuery.filter = `(${correctedQuery.filter}) and ${geoFilter}`;
                    }
                    else {
                        correctedQuery.filter = geoFilter;
                    }
                    //Higher the fetched things to 1000, if not set
                    if (!correctedQuery.top)
                        correctedQuery.top = 1000;
                    //Fetch the data from the server, next links are handled by the STAInterface and merged into one object
                    var rawGeoJson = yield this.api.getGeoJson(correctedQuery);
                    //If any data was returned
                    if (rawGeoJson) {
                        var locations;
                        //Map the response to one array of geoJson Features
                        if (correctedQuery.entityType == 'Things') {
                            locations = rawGeoJson.value.map((data) => {
                                return data.Locations[0].location;
                            });
                        }
                        else {
                            //Get the location from the FeaturesOfInterest
                            locations = rawGeoJson.value.map((data) => {
                                return data.feature;
                            });
                        }
                        //Add an object to the cache, if it is the first time for this zoom level
                        if (!this.cache[zoom]) {
                            this.cache[zoom] = {
                                "type": "FeatureCollection",
                                "features": []
                            };
                        }
                        this.cache[zoom].features.push(...locations);
                        /*
                
                        //Check if GeoJson Type is point, if not the GeoJson is not gonna be changed
                        if (locations[0] && locations[0].type == "Point") {
                          //Create cluster from the points
                          await this.cluster(locations, zoom);
                        } else {
                          this.cache[zoom].features.push(...locations);
                        }
                        */
                    }
                }
                return this.cache[zoom];
            });
        }
        /*
        private async cluster(locations: any, zoom: number) {
          locations = locations.map((location: any) => {
            //Get the coordinates of the top left point of the OSM tile the point intersects with
            var top = this.coordinatesToOsm({
              lat: location.coordinates[0],
              lng: location.coordinates[1]
            }, zoom);
      
            //Get the coordinates of the bottom right point of the OSM tile the point intersects with
            var bottom = this.coordinatesToOsmBottom({
              lat: location.coordinates[0],
              lng: location.coordinates[1]
            }, zoom);
      
            //Create a geojson with the coordinates. Duplicates will be filtered later.
            var obj = {
              "type": "Feature",
              "geometry": {
                "type": "Polygon",
                "coordinates": [
                  [
                    [top.lat, top.lng],
                    [top.lat, bottom.lng],
                    [bottom.lat, bottom.lng],
                    [bottom.lat, top.lng],
                    [top.lat, top.lng]
                  ]
                ]
              },
              "properties": {
                "count": 1
              }
            };
            return obj;
          });
      
          var tiles: any = [];
      
          //Remove duplicates, increase counter if duplicate
          locations.forEach((feature: any) => {
            var existing = tiles.find((feature2: any) => {
              return compare_features(feature, feature2);
            });
      
            if (!existing) {
              tiles.push(feature);
            }
            else {
              existing.properties.count = existing.properties.count + 1;
            }
          });
      
          //Filter out all existing tiles
          tiles = tiles.filter((feature: any) => {
            return !this.cache[zoom].features.some((feature2: any) => {
              return compare_features(feature, feature2);
            })
          });
      
          //Getting all markers
          var toMarker: any = [];
      
          tiles = tiles.filter((geo: any) => {
            //Remove tiles with less than configured things inside
            if (geo.properties.count < this.config.clusterMin) {
              //Push all clusters, that should be displayed as markers to the toMarker array
              toMarker.push([geo.geometry.coordinates]);
              return false;
            }
            else {
              return true;
            }
          });
      
          //Push tiles to cache
          this.cache[zoom].features.push(...tiles);
      
          //Check if any markers should be loaded
          await this.getMarkers(toMarker, zoom);
        }
        */
        getMarkers(toMarker, zoom) {
            return __awaiter(this, void 0, void 0, function* () {
                if (toMarker.length != 0) {
                    //Create union out of all clusters to reduce the ST filter length
                    var combine = poly.union(...toMarker);
                    //Check if a result was returned
                    if (combine) {
                        //Remove reference to config.queryObject
                        var markerQuery = JSON.parse(JSON.stringify(this.config.queryObject));
                        markerQuery.top = 1000;
                        if (markerQuery.entityType == "Things") {
                            //Check if expand is specified in the queryObject
                            if (!markerQuery.expand)
                                markerQuery.expand = [];
                            //Check if a queryObject to expand the datastream with id and name is specified
                            var datastreamQuery = markerQuery.expand.find((expand) => {
                                return expand.entityType == 'Datastreams';
                            });
                            if (!datastreamQuery) {
                                markerQuery.expand.push({
                                    entityType: "Datastreams",
                                    select: ["id", "name"],
                                    expand: [{ entityType: 'observedProperty' }]
                                });
                            }
                            else {
                                if (datastreamQuery.select && !datastreamQuery.select.includes("id")) {
                                    datastreamQuery.select.push("id");
                                }
                                if (datastreamQuery.select && !datastreamQuery.select.includes("name")) {
                                    datastreamQuery.select.push("name");
                                }
                            }
                            //Check if the Location was expanded
                            if (!markerQuery.expand.some((expand) => {
                                return expand.entityType == 'Locations';
                            })) {
                                markerQuery.expand.push({
                                    entityType: "Locations",
                                });
                            }
                        }
                        else {
                            //Add feature to select, if it queries for the FeaturesOfInterest
                            if (markerQuery.select && !markerQuery.select.includes('feature')) {
                                markerQuery.select.push('feature');
                            }
                        }
                        //If a filter is already specified, append the geometry query to the old filter
                        if (markerQuery.filter)
                            markerQuery.filter = `(${markerQuery.filter}) and `;
                        markerQuery.filter = markerQuery.filter ? markerQuery.filter : '' + polygonToFilter(combine, markerQuery.entityType);
                        //Get the data for the markers
                        var markers = yield this.api.getGeoJson(markerQuery);
                        //Iterate all markers
                        markers.value.forEach((marker) => {
                            //Get the geoJson of the marker
                            var geoJson;
                            if (markerQuery.entityType == 'Things')
                                geoJson = marker.Locations[0].location;
                            else
                                geoJson = marker.feature;
                            //Fix the geojson if it is not nested in a feature, because openlayer wouldn't save the properties 
                            if (geoJson.type == "Point") {
                                geoJson =
                                    {
                                        "type": "Feature",
                                        "geometry": geoJson
                                    };
                            }
                            delete marker.Locations;
                            geoJson.properties = marker;
                            if (!marker.getData)
                                marker.getData = {};
                            if (markerQuery.entityType == 'Things') {
                                //Iterate through the datastreams
                                for (var datastream of marker.Datastreams) {
                                    marker.getData[datastream.ObservedProperty.name] = function (filter) {
                                        var datastreamQuery = { entityType: "Datastreams", id: datastream['@iot.id'], expand: [{ entityType: "Observations", filter }] };
                                        return this.api.getGeoJson(datastreamQuery);
                                    }.bind(this);
                                }
                            }
                            //Check if the marker is already in the cache
                            if (!this.cache[zoom].features.some((feature) => {
                                return compare_features(geoJson, feature);
                            })) {
                                this.cache[zoom].features.push(geoJson);
                            }
                        });
                    }
                }
            });
        }
    }
    /**
     *
     * @param f1 feature to be compared
     * @param f2 feature to be compared
     * @returns true if the features are the same
     */
    function compare_features(f1, f2) {
        //Check if the type is the same
        if (f1.type != f2.type)
            return false;
        //If feature is a point, the coordinates can be compared directly
        if (f1.type == "Point")
            return polygon_compare(f1.coordinates, f2.coordinates);
        //If it is a polygon or something else, the coordinates need to be gotten from the geometry object
        return polygon_compare(f1.geometry.coordinates, f2.geometry.coordinates);
    }
    /**
     * Deep comparing two arrays
     * @param a1 Array to be compared
     * @param a2 Array to be compared
     * @returns true if the same
     */
    function polygon_compare(a1, a2) {
        return JSON.stringify(a1) === JSON.stringify(a2);
    }
    /**
     * Converts a polygon into a valid filter for a sensorthings API
     * @param multipolygon polygon or multipolygon to convert
     * @returns valid filter
     */
    function polygonToFilter(multipolygon, entityType) {
        return multipolygon.map((polygon) => {
            //Check if polygon is a multipolygon
            if (polygon[0][0][0] != undefined) {
                //Multipolygon
                polygon = polygon[0];
            }
            return `geo.intersects(${entityType == 'Things' ? 'Locations/location' : 'feature'},geography'POLYGON ((${polygon.map((array) => { return array.join(' '); }).join(',')}))')`;
        }).join(' or ');
    }

    var colorMarkers = {
        blueIcon: new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        }),
        goldIcon: (new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-gold.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        })),
        redIcon: (new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        })),
        greenIcon: (new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        })),
        orangeIcon: new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        }),
        yellowIcon: new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        }),
        violetIcon: new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        }),
        greyIcon: new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-grey.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        }),
        blackIcon: new L.Icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-black.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        })
    };
    function textToMarker(color) {
        switch (color) {
            case "green": return colorMarkers.greenIcon;
            case "black": return colorMarkers.blackIcon;
            case "blue": return colorMarkers.blueIcon;
            case "grey": return colorMarkers.greyIcon;
            case "violet": return colorMarkers.violetIcon;
            case "yellow": return colorMarkers.yellowIcon;
            case "red": return colorMarkers.redIcon;
            case "orange": return colorMarkers.orangeIcon;
            case "gold": return colorMarkers.goldIcon;
            default: return new L.Icon.Default();
        }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var picoModal = createCommonjsModule(function (module) {
    /**
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */

    (function (root, factory) {

        if ( module.exports) {
            module.exports = factory();
        }
        else {
            root.picoModal = factory();
        }
    }(commonjsGlobal, function () {

        /** Returns whether a value is a dom node */
        function isNode(value) {
            if ( typeof Node === "object" ) {
                return value instanceof Node;
            }
            else {
                return value && typeof value === "object" && typeof value.nodeType === "number";
            }
        }

        /** Returns whether a value is a string */
        function isString(value) {
            return typeof value === "string";
        }

        /**
         * Generates observable objects that can be watched and triggered
         */
        function observable() {
            var callbacks = [];
            return {
                watch: callbacks.push.bind(callbacks),
                trigger: function(context, detail) {

                    var unprevented = true;
                    var event = {
                        detail: detail,
                        preventDefault: function preventDefault () {
                            unprevented = false;
                        }
                    };

                    for (var i = 0; i < callbacks.length; i++) {
                        callbacks[i](context, event);
                    }

                    return unprevented;
                }
            };
        }


        /** Whether an element is hidden */
        function isHidden ( elem ) {
            // @see http://stackoverflow.com/questions/19669786
            return window.getComputedStyle(elem).display === 'none';
        }


        /**
         * A small interface for creating and managing a dom element
         */
        function Elem( elem ) {
            this.elem = elem;
        }

        /** Creates a new div */
        Elem.make = function ( parent, tag ) {
            if ( typeof parent === "string" ) {
                parent = document.querySelector(parent);
            }
            var elem = document.createElement(tag || 'div');
            (parent || document.body).appendChild(elem);
            return new Elem(elem);
        };

        Elem.prototype = {

            /** Creates a child of this node */
            child: function (tag) {
                return Elem.make(this.elem, tag);
            },

            /** Applies a set of styles to an element */
            stylize: function(styles) {
                styles = styles || {};

                if ( typeof styles.opacity !== "undefined" ) {
                    styles.filter = "alpha(opacity=" + (styles.opacity * 100) + ")";
                }

                for (var prop in styles) {
                    if (styles.hasOwnProperty(prop)) {
                        this.elem.style[prop] = styles[prop];
                    }
                }

                return this;
            },

            /** Adds a class name */
            clazz: function (clazz) {
                this.elem.className += " " + clazz;
                return this;
            },

            /** Sets the HTML */
            html: function (content) {
                if ( isNode(content) ) {
                    this.elem.appendChild( content );
                }
                else {
                    this.elem.innerHTML = content;
                }
                return this;
            },

            /** Adds a click handler to this element */
            onClick: function(callback) {
                this.elem.addEventListener('click', callback);
                return this;
            },

            /** Removes this element from the DOM */
            destroy: function() {
                this.elem.parentNode.removeChild(this.elem);
            },

            /** Hides this element */
            hide: function() {
                this.elem.style.display = "none";
            },

            /** Shows this element */
            show: function() {
                this.elem.style.display = "block";
            },

            /** Sets an attribute on this element */
            attr: function ( name, value ) {
                if (value !== undefined) {
                    this.elem.setAttribute(name, value);
                }
                return this;
            },

            /** Executes a callback on all the ancestors of an element */
            anyAncestor: function ( predicate ) {
                var elem = this.elem;
                while ( elem ) {
                    if ( predicate( new Elem(elem) ) ) {
                        return true;
                    }
                    else {
                        elem = elem.parentNode;
                    }
                }
                return false;
            },

            /** Whether this element is visible */
            isVisible: function () {
                return !isHidden(this.elem);
            }
        };


        /** Generates the grey-out effect */
        function buildOverlay( getOption, close ) {
            return Elem.make( getOption("parent") )
                .clazz("pico-overlay")
                .clazz( getOption("overlayClass", "") )
                .stylize({
                    display: "none",
                    position: "fixed",
                    top: "0px",
                    left: "0px",
                    height: "100%",
                    width: "100%",
                    zIndex: 10000
                })
                .stylize(getOption('overlayStyles', {
                    opacity: 0.5,
                    background: "#000"
                }))
                .onClick(function () {
                    if ( getOption('overlayClose', true) ) {
                        close();
                    }
                });
        }

        // An auto incrementing ID assigned to each modal
        var autoinc = 1;

        /** Builds the content of a modal */
        function buildModal( getOption, close ) {
            var width = getOption('width', 'auto');
            if ( typeof width === "number" ) {
                width = "" + width + "px";
            }

            var id = getOption("modalId", "pico-" + autoinc++);

            var elem = Elem.make( getOption("parent") )
                .clazz("pico-content")
                .clazz( getOption("modalClass", "") )
                .stylize({
                    display: 'none',
                    position: 'fixed',
                    zIndex: 10001,
                    left: "50%",
                    top: "38.1966%",
                    maxHeight: '90%',
                    boxSizing: 'border-box',
                    width: width,
                    '-ms-transform': 'translate(-50%,-38.1966%)',
                    '-moz-transform': 'translate(-50%,-38.1966%)',
                    '-webkit-transform': 'translate(-50%,-38.1966%)',
                    '-o-transform': 'translate(-50%,-38.1966%)',
                    transform: 'translate(-50%,-38.1966%)'
                })
                .stylize(getOption('modalStyles', {
                    overflow: 'auto',
                    backgroundColor: "white",
                    padding: "20px",
                    borderRadius: "5px"
                }))
                .html( getOption('content') )
                .attr("id", id)
                .attr("role", "dialog")
                .attr("aria-labelledby", getOption("ariaLabelledBy"))
                .attr("aria-describedby", getOption("ariaDescribedBy", id))
                .onClick(function (event) {
                    var isCloseClick = new Elem(event.target).anyAncestor(function (elem) {
                        return /\bpico-close\b/.test(elem.elem.className);
                    });
                    if ( isCloseClick ) {
                        close();
                    }
                });

            return elem;
        }

        /** Builds the close button */
        function buildClose ( elem, getOption ) {
            if ( getOption('closeButton', true) ) {
                return elem.child('button')
                    .html( getOption('closeHtml', "&#xD7;") )
                    .clazz("pico-close")
                    .clazz( getOption("closeClass", "") )
                    .stylize( getOption('closeStyles', {
                        borderRadius: "2px",
                        border: 0,
                        padding: 0,
                        cursor: "pointer",
                        height: "15px",
                        width: "15px",
                        position: "absolute",
                        top: "5px",
                        right: "5px",
                        fontSize: "16px",
                        textAlign: "center",
                        lineHeight: "15px",
                        background: "#CCC"
                    }) )
                    .attr("aria-label", getOption("close-label", "Close"));
            }
        }

        /** Builds a method that calls a method and returns an element */
        function buildElemAccessor( builder ) {
            return function () {
                return builder().elem;
            };
        }


        // An observable that is triggered whenever the escape key is pressed
        var escapeKey = observable();

        // An observable that is triggered when the user hits the tab key
        var tabKey = observable();

        /** A global event handler to detect the escape key being pressed */
        document.documentElement.addEventListener('keydown', function onKeyPress (event) {
            var keycode = event.which || event.keyCode;

            // If this is the escape key
            if ( keycode === 27 ) {
                escapeKey.trigger();
            }

            // If this is the tab key
            else if ( keycode === 9 ) {
                tabKey.trigger(event);
            }
        });


        /** Attaches focus management events */
        function manageFocus ( iface, isEnabled ) {

            /** Whether an element matches a selector */
            function matches ( elem, selector ) {
                var fn = elem.msMatchesSelector || elem.webkitMatchesSelector || elem.matches;
                return fn.call(elem, selector);
            }

            /**
             * Returns whether an element is focusable
             * @see http://stackoverflow.com/questions/18261595
             */
            function canFocus( elem ) {
                if (
                    isHidden(elem) ||
                    matches(elem, ":disabled") ||
                    elem.hasAttribute("contenteditable")
                ) {
                    return false;
                }
                else {
                    return elem.hasAttribute("tabindex") ||
                        matches(elem, "input,select,textarea,button,a[href],area[href],iframe");
                }
            }

            /** Returns the first descendant that can be focused */
            function firstFocusable ( elem ) {
                var items = elem.getElementsByTagName("*");
                for (var i = 0; i < items.length; i++) {
                    if ( canFocus(items[i]) ) {
                        return items[i];
                    }
                }
            }

            /** Returns the last descendant that can be focused */
            function lastFocusable ( elem ) {
                var items = elem.getElementsByTagName("*");
                for (var i = items.length; i--;) {
                    if ( canFocus(items[i]) ) {
                        return items[i];
                    }
                }
            }

            // The element focused before the modal opens
            var focused;

            // Records the currently focused element so state can be returned
            // after the modal closes
            iface.beforeShow(function getActiveFocus() {
                focused = document.activeElement;
            });

            // Shift focus into the modal
            iface.afterShow(function focusModal() {
                if ( isEnabled() ) {
                    var focusable = firstFocusable(iface.modalElem());
                    if ( focusable ) {
                        focusable.focus();
                    }
                }
            });

            // Restore the previously focused element when the modal closes
            iface.afterClose(function returnFocus() {
                if ( isEnabled() && focused ) {
                    focused.focus();
                }
                focused = null;
            });

            // Capture tab key presses and loop them within the modal
            tabKey.watch(function tabKeyPress (event) {
                if ( isEnabled() && iface.isVisible() ) {
                    var first = firstFocusable(iface.modalElem());
                    var last = lastFocusable(iface.modalElem());

                    var from = event.shiftKey ? first : last;
                    if ( from === document.activeElement ) {
                        (event.shiftKey ? last : first).focus();
                        event.preventDefault();
                    }
                }
            });
        }

        /** Manages setting the 'overflow: hidden' on the body tag */
        function manageBodyOverflow(iface, isEnabled) {
            var origOverflow;
            var body = new Elem(document.body);

            iface.beforeShow(function () {
                // Capture the current values so they can be restored
                origOverflow = body.elem.style.overflow;

                if (isEnabled()) {
                    body.stylize({ overflow: "hidden" });
                }
            });

            iface.afterClose(function () {
                body.stylize({ overflow: origOverflow });
            });
        }

        /**
         * Displays a modal
         */
        return function picoModal(options) {

            if ( isString(options) || isNode(options) ) {
                options = { content: options };
            }

            var afterCreateEvent = observable();
            var beforeShowEvent = observable();
            var afterShowEvent = observable();
            var beforeCloseEvent = observable();
            var afterCloseEvent = observable();

            /**
             * Returns a named option if it has been explicitly defined. Otherwise,
             * it returns the given default value
             */
            function getOption ( opt, defaultValue ) {
                var value = options[opt];
                if ( typeof value === "function" ) {
                    value = value( defaultValue );
                }
                return value === undefined ? defaultValue : value;
            }


            // The various DOM elements that constitute the modal
            var modalElem = build.bind(window, 'modal');
            var shadowElem = build.bind(window, 'overlay');
            var closeElem = build.bind(window, 'close');

            // This will eventually contain the modal API returned to the user
            var iface;


            /** Hides this modal */
            function forceClose (detail) {
                shadowElem().hide();
                modalElem().hide();
                afterCloseEvent.trigger(iface, detail);
            }

            /** Gracefully hides this modal */
            function close (detail) {
                if ( beforeCloseEvent.trigger(iface, detail) ) {
                    forceClose(detail);
                }
            }

            /** Wraps a method so it returns the modal interface */
            function returnIface ( callback ) {
                return function () {
                    callback.apply(this, arguments);
                    return iface;
                };
            }


            // The constructed dom nodes
            var built;

            /** Builds a method that calls a method and returns an element */
            function build (name, detail) {
                if ( !built ) {
                    var modal = buildModal(getOption, close);
                    built = {
                        modal: modal,
                        overlay: buildOverlay(getOption, close),
                        close: buildClose(modal, getOption)
                    };
                    afterCreateEvent.trigger(iface, detail);
                }
                return built[name];
            }

            iface = {

                /** Returns the wrapping modal element */
                modalElem: buildElemAccessor(modalElem),

                /** Returns the close button element */
                closeElem: buildElemAccessor(closeElem),

                /** Returns the overlay element */
                overlayElem: buildElemAccessor(shadowElem),

                /** Builds the dom without showing the modal */
                buildDom: returnIface(build.bind(null, null)),

                /** Returns whether this modal is currently being shown */
                isVisible: function () {
                    return !!(built && modalElem && modalElem().isVisible());
                },

                /** Shows this modal */
                show: function (detail) {
                    if ( beforeShowEvent.trigger(iface, detail) ) {
                        shadowElem().show();
                        closeElem();
                        modalElem().show();
                        afterShowEvent.trigger(iface, detail);
                    }
                    return this;
                },

                /** Hides this modal */
                close: returnIface(close),

                /**
                 * Force closes this modal. This will not call beforeClose
                 * events and will just immediately hide the modal
                 */
                forceClose: returnIface(forceClose),

                /** Destroys this modal */
                destroy: function () {
                    modalElem().destroy();
                    shadowElem().destroy();
                    shadowElem = modalElem = closeElem = undefined;
                },

                /**
                 * Updates the options for this modal. This will only let you
                 * change options that are re-evaluted regularly, such as
                 * `overlayClose`.
                 */
                options: function ( opts ) {
                    Object.keys(opts).map(function (key) {
                        options[key] = opts[key];
                    });
                },

                /** Executes after the DOM nodes are created */
                afterCreate: returnIface(afterCreateEvent.watch),

                /** Executes a callback before this modal is closed */
                beforeShow: returnIface(beforeShowEvent.watch),

                /** Executes a callback after this modal is shown */
                afterShow: returnIface(afterShowEvent.watch),

                /** Executes a callback before this modal is closed */
                beforeClose: returnIface(beforeCloseEvent.watch),

                /** Executes a callback after this modal is closed */
                afterClose: returnIface(afterCloseEvent.watch)
            };

            manageFocus(iface, getOption.bind(null, "focus", true));

            manageBodyOverflow(iface, getOption.bind(null, "bodyOverflow", true));

            // If a user presses the 'escape' key, close the modal.
            escapeKey.watch(function escapeKeyPress () {
                if ( getOption("escCloses", true) && iface.isVisible() ) {
                    iface.close();
                }
            });

            return iface;
        };

    }));
    });

    //Leaflet
    if (typeof L !== "undefined") {
        //All leaflet layers are stored in
        var layers = [];
        //Layer that represents all count circles and tooltips
        var countLayer;
        //Extend a LayerGroup
        L.Stam = L.LayerGroup.extend({
            initialize: function (config) {
                var mapInterface = new MapInterface(config);
                var highlight;
                //Used for setting the style of a polygon when it is hovered
                var setHighlight = function (layer) {
                    // Check if something's highlighted, if so unset highlight
                    if (highlight) {
                        unsetHighlight(highlight);
                    }
                    // Set highlight style on layer and store to variable
                    layer.setStyle(style.highlight);
                    highlight = layer;
                };
                //Remove the style after the mouse hovered over a polygon
                var unsetHighlight = function (layer) {
                    // Set default style and clear variable
                    layer.setStyle(style.default);
                    highlight = null;
                };
                //TODO use style from config
                var style = {
                    'default': {
                        'opacity': 0,
                        'fillOpacity': 0
                    },
                    'highlight': {
                        'color': 'red',
                        'opacity': 1,
                    }
                };
                //Called when the layer is added to the map
                this.on('add', function () {
                    if (this._map != undefined) {
                        //Flag if the countLayer should be cleared
                        var clearCluster;
                        var map = this._map;
                        var zoom = map.getZoom();
                        //Called on every feature of the map
                        var onEachFeature = (feature, layer) => {
                            var _a;
                            //Check if the countLayer should be cleared
                            if (clearCluster) {
                                countLayer.clearLayers();
                                clearCluster = false;
                            }
                            //Check if a polygon is cluster generated by the library and a polygon
                            if (((_a = feature.geometry) === null || _a === void 0 ? void 0 : _a.type) == 'Polygon' && feature.properties.count) {
                                //Check for mouse hover
                                layer.on('mouseover', function () {
                                    if (config.clusterMouseOver)
                                        config.clusterMouseOver(feature);
                                    //Highlight the polygon with the given style
                                    setHighlight(layer);
                                });
                                layer.on('mouseout', function () {
                                    unsetHighlight(layer);
                                });
                                layer.on('click', function () {
                                    //Configure a click on the cluster, if nothing is configured or nothing returned, the map zooms to the bounds of the polygon 
                                    if (config.clusterClick) {
                                        var out = config.clusterClick(feature);
                                        if (out)
                                            return layer.bindPopup(out);
                                    }
                                    map.fitBounds(layer.getBounds());
                                });
                                //Set the default style of a polygon
                                layer.setStyle(style.default);
                                //Get the bounds and calculate the center of the polygon
                                var bounds = layer.getBounds();
                                var lat = (bounds._northEast.lat + bounds._southWest.lat) / 2;
                                var lng = (bounds._northEast.lng + bounds._southWest.lng) / 2;
                                //Position a circle in the center
                                var circle = L.circleMarker(L.latLng(lat, lng), {
                                    radius: zoom * 3
                                });
                                //Add the count of things inside the polygon to the circle
                                circle.bindTooltip(`<span>${feature.properties.count}</span>`, { permanent: true, direction: "center", className: 'count' });
                                //Add the circle to the countLayer
                                countLayer.addLayer(circle);
                            }
                            else {
                                var defaultPopup = true;
                                //Used for creating the default popup body
                                layer.on('popupopen', function () {
                                    if (defaultPopup) {
                                        //Get the popup body
                                        var popupElement = document.getElementsByClassName('leaflet-popup-content')[0];
                                        createDefaultPopup(popupElement, feature);
                                    }
                                });
                                //Add a click event to the markers
                                layer.on('click', function () {
                                    //Bind popup with functions return if present
                                    if (config.markerClick) {
                                        var out = config.markerClick(feature);
                                        if (out) {
                                            defaultPopup = false;
                                            return layer.bindPopup(out);
                                        }
                                    }
                                    //Default behavior 
                                    layer.bindPopup('<h3>' + feature.properties.name + '</h3>');
                                });
                                layer.on('mouseover', function () {
                                    if (config.markerMouseOver)
                                        return config.markerMouseOver(feature);
                                });
                            }
                        };
                        //Used for marker styling
                        var pointToLayer = function (feature, latlng) {
                            //Marker coloring
                            var marker = L.marker(latlng, { icon: typeof config.markerStyle == 'function' ? textToMarker(config.markerStyle(feature)) : typeof config.markerStyle == 'string' ? textToMarker(config.markerStyle) : new L.Icon.Default() });
                            return marker;
                        };
                        //Called when the LayerGroup was added to the map, then the LayerGroup's super class is done initiating 
                        map.on('layeradd', function () {
                            //Remove callback
                            map.off('layeradd');
                            //Initiade the count layer and add it to this layer group
                            countLayer = L.layerGroup();
                            this.addLayer(countLayer);
                            //Initiate the layer group with the current bounds and zoom level
                            var bounds = map.getBounds();
                            mapInterface.getLayerData(map.getZoom(), [bounds._northEast.lng, bounds._northEast.lat, bounds._southWest.lng, bounds._southWest.lat]).then((geojson) => {
                                //Create a geoJson layer and add it to the layers array and to this layer group
                                var geoJsonLayer = L.geoJSON(geojson, {
                                    onEachFeature,
                                    pointToLayer,
                                    style: config.clusterStyle
                                });
                                layers.push(geoJsonLayer);
                                this.addLayer(geoJsonLayer);
                            });
                        });
                        //Called when zoom ended or the map was moved. The geojson layer is removed and a new one added, because the loaded geojson's are cached inside the MapInterface
                        map.on('moveend', function () {
                            //Update the zoom variable if the zoom was changed
                            if (zoom != map.getZoom()) {
                                zoom = map.getZoom();
                            }
                            //Set flag to true so that the cluster labels are removed
                            clearCluster = true;
                            var bounds = map.getBounds();
                            //add a new layer and remove all old layers
                            mapInterface.getLayerData(map.getZoom(), [bounds._northEast.lng, bounds._northEast.lat, bounds._southWest.lng, bounds._southWest.lat]).then((geojson) => {
                                var geoJsonLayer = L.geoJSON(geojson, {
                                    onEachFeature,
                                    pointToLayer,
                                    style: config.clusterStyle
                                });
                                layers.forEach((layer) => {
                                    layer.remove();
                                });
                                layers.push(geoJsonLayer);
                                this.addLayer(geoJsonLayer);
                            });
                        });
                    }
                });
            },
        });
        L.stam = function (config) {
            return new L.Stam(config);
        };
        //Adding custom css to head, so that the count tooltipp's background is transparent
        var css = '.leaflet-tooltip.count {background-color: transparent;border: transparent;  box-shadow: none;  font-weight: bold;font-size: 20px;}', head = document.head || document.getElementsByTagName('head')[0], style = document.createElement('style');
        head.appendChild(style);
        style.type = 'text/css';
        if (style.styleSheet) {
            // This is required for IE8 and below.
            style.styleSheet.cssText = css;
        }
        else {
            style.appendChild(document.createTextNode(css));
        }
    }
    if (typeof ol != "undefined") {
        //Adding css style for the marker popup
        var css = `.ol-popup{position:absolute;min-width:180px;background-color:#fff;-webkit-filter:drop-shadow(0 1px 4px rgba(0, 0, 0, .2));filter:drop-shadow(0 1px 4px rgba(0, 0, 0, .2));padding:15px;border-radius:10px;border:1px solid #ccc;bottom:40px;left:-50px}.ol-popup:after,.ol-popup:before{top:100%;border:solid transparent;content:" ";height:0;width:0;position:absolute;pointer-events:none}.ol-popup:after{border-top-color:#fff;border-width:10px;left:48px;margin-left:-10px}.ol-popup:before{border-top-color:#ccc;border-width:11px;left:48px;margin-left:-11px}.ol-popup-closer{text-decoration:none;position:absolute;top:2px;right:8px}.ol-popup-closer:after{content:"✖"}`, head = document.head || document.getElementsByTagName('head')[0], style = document.createElement('style');
        head.appendChild(style);
        style.type = 'text/css';
        if (style.styleSheet) {
            // This is required for IE8 and below.
            style.styleSheet.cssText = css;
        }
        else {
            style.appendChild(document.createTextNode(css));
        }
        //Since ol 6 ol.inherits was removed
        var ol_ext_inherits = function (child, parent) {
            child.prototype = Object.create(parent.prototype);
            child.prototype.constructor = child;
        };
        var zoom;
        //Contains all layers that where added by the library, this.getLayers() returns all layers
        var olLayers = [];
        var olmap;
        /**
         * STAM implementation for openLayers
         * @param config STAM configuration object
         */
        var ol_layer_stam = function (config) {
            //Get map instance from config
            olmap = config.map;
            //Init LayerGroup
            ol.layer.Group.call(this, config);
            //Get current zoom level and remove all decimal places
            zoom = olmap.getView().getZoom().toFixed(0);
            var mapInterface = new MapInterface(config);
            //If popup is not in the html dom, add it
            if (!document.getElementById('popup')) {
                document.writeln(`<div id="popup" class="ol-popup">
      <a href="#" id="popup-closer" class="ol-popup-closer"></a>
      <div id="popup-content"></div>
      </div>`);
            }
            //Creating the popup
            var container = document.getElementById('popup'), content_element = document.getElementById('popup-content'), closer = document.getElementById('popup-closer');
            //Marker close event
            closer.onclick = function () {
                overlay.setPosition(undefined);
                closer.blur();
                return false;
            };
            //Create overlay for popup
            var overlay = new ol.Overlay({
                element: container,
                autoPan: true,
                offset: [0, -10]
            });
            //Add popup to map
            olmap.addOverlay(overlay);
            //Cursor as pointer when over a marker
            olmap.on("pointermove", function (evt) {
                var hit = this.forEachFeatureAtPixel(evt.pixel, function (feature, layer) {
                    return feature.get('name') != "cluster";
                });
                if (hit) {
                    this.getTargetElement().style.cursor = 'pointer';
                }
                else {
                    this.getTargetElement().style.cursor = '';
                }
            });
            //Map onclick
            olmap.on('click', function (evt) {
                //Get the clicked feature
                var feature = olmap.forEachFeatureAtPixel(evt.pixel, function (feature, layer) {
                    return feature;
                });
                //Check if feature was clicked
                if (feature) {
                    var geometry = feature.getGeometry();
                    var coord = geometry.getCoordinates();
                    var content;
                    //Check type
                    if (typeof config.markerClick == 'function') {
                        content = config.markerClick(olToGeoJSON(feature));
                    }
                    //If no content, just insert the default content
                    if (!content) {
                        createDefaultPopup(content_element, olToGeoJSON(feature));
                    }
                    else {
                        content_element.innerHTML = content;
                    }
                    overlay.setPosition(coord);
                }
            });
            //Add listener to moveend, called when moving and zooming;
            olmap.on("moveend", function () {
                //Check if zoom level was changed
                if (zoom != olmap.getView().getZoom()) {
                    zoom = olmap.getView().getZoom().toFixed(0);
                }
                //always add new layer, because the geojson is cached inside MapInterface.ts
                addSTAMLayer(mapInterface, zoom, config).then(function (layer) {
                    this.getLayers().array_.push(layer);
                    this.changed();
                    //remove all old layers, if they are inside the olLayers array
                    this.getLayers().array_ = this.getLayers().array_.filter(function (layer) {
                        if (olLayers.indexOf(layer) != -1) {
                            return false;
                        }
                        return true;
                    }.bind(this));
                    //Force a map render when layer is changed
                    layer.on('change', () => { olmap.render(); });
                    olmap.render();
                    //Clear the olLayers array and push the new layer
                    olLayers = [];
                    olLayers.push(layer);
                }.bind(this));
            });
        };
        //Inherit the layer group from openLayers
        ol_ext_inherits(ol_layer_stam, ol.layer.Group);
        //Add the layer to ol.layer.STAM
        ol.layer.STAM = ol_layer_stam;
    }
    /**
     * Adds the default body to a popup
     * @param content_element popup content element
     * @param feature GeoJSON feature that was clicked
     */
    function createDefaultPopup(content_element, feature) {
        content_element.innerHTML = '<h3>' + feature.properties.name + '</h3>';
        var list = document.createElement('ul');
        //Iterate all ObservedProperties
        Object.keys(feature.properties.getData).forEach((key) => {
            //Create new list element
            var li = document.createElement('li');
            li.innerText = key;
            //Set cursor style on hover
            li.setAttribute('style', "cursor: pointer");
            li.onclick = function () {
                //Create new popup
                picoModal({
                    width: 1140, content: '', modalId: 'pico-1'
                }).beforeClose(function () {
                    Plotly.purge("pico-1");
                    //Remove pico-1 element from DOM
                    document.getElementById("pico-1").remove();
                }).afterShow(function () {
                    //SHOW diagram
                    var trace1 = {
                        x: [0, 1, 2, 3, 4, 5, 6, 7, 8],
                        y: [8, 7, 6, 5, 4, 3, 2, 1, 0],
                        type: 'scatter'
                    };
                    var trace2 = {
                        x: [0, 1, 2, 3, 4, 5, 6, 7, 8],
                        y: [0, 1, 2, 3, 4, 5, 6, 7, 8],
                        type: 'scatter'
                    };
                    var data = [trace1, trace2];
                    var layout = {
                        height: 300,
                        xaxis: {
                            autorange: true
                        },
                        yaxis: {
                            autorange: true
                        },
                        autosize: true
                    };
                    Plotly.newPlot('pico-1', data, layout);
                }).show();
            };
            //Append to list
            list.appendChild(li);
        });
        //Append list to popup
        content_element.appendChild(list);
    }
    /**
     * Creates a stam layer
     * @param mapInterface mapInterface instance
     * @param zoom current zoom level
     * @returns a promise that resolves with an openLayers vectorLayer that contains the geoJson
     */
    function addSTAMLayer(mapInterface, zoom, config) {
        return new Promise(function (resolve, reject) {
            var bounds;
            //Check it the projection is EPSG 4326
            if (olmap.getView().getProjection().getCode() == "EPSG:4326")
                bounds = olmap.getView().calculateExtent();
            else {
                //If not convert the bounding box to EPSG 4326
                var zw = olmap.getView().calculateExtent();
                var code = olmap.getView().getProjection().getCode();
                bounds = [];
                bounds.push(...(new ol.geom.Point([zw[2], zw[3]])).transform(code, 'EPSG:4326').getCoordinates());
                bounds.push(...(new ol.geom.Point([zw[0], zw[1]])).transform(code, 'EPSG:4326').getCoordinates());
            }
            //Fetch the geojson
            mapInterface.getLayerData(zoom, bounds).then((geoJson) => {
                //Create the geojson with  geojson and set the featureProjection to the view's projection
                var vectorSource = new ol.source.Vector({
                    features: new ol.format.GeoJSON().readFeatures(geoJson, { featureProjection: olmap.getView().getProjection().getCode() }),
                });
                var circleSource = new ol.source.Vector();
                var circleLayer = new ol.layer.Vector({ source: circleSource });
                //Create the vectorLayer with the geojson vector source
                var vectorLayer = new ol.layer.Vector({
                    source: vectorSource,
                    // features,
                    style: function (feature) {
                        //Check the feature type
                        if (feature.getGeometry().getType() == "Point") {
                            //Add the marker image
                            var style = new ol.style.Style({
                                image: new ol.style.Icon(({
                                    anchor: [0.5, 1],
                                    scale: 0.5,
                                    anchorXUnits: 'fraction',
                                    anchorYUnits: 'fraction',
                                    //Call function if present, with the feature, if not use the color name if present. Default is blue
                                    src: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${typeof config.markerStyle == 'function' ? config.markerStyle(olToGeoJSON(feature)) : config.markerStyle ? config.markerStyle : 'blue'}.png`
                                })),
                            });
                            return style;
                        }
                        else {
                            if (feature.get('count') != undefined) {
                                //Get extends of cluster
                                var cords = feature.getGeometry().getExtent();
                                //Calculate middle
                                var long = (cords[0] + cords[2]) / 2;
                                var lat = (cords[1] + cords[3]) / 2;
                                //Add circle with text
                                var circle = new ol.Feature({ geometry: new ol.geom.Circle([long, lat], (cords[2] - cords[0]) / 6), name: 'cluster' });
                                circle.setStyle(new ol.style.Style({
                                    stroke: new ol.style.Stroke({
                                        width: 2,
                                        color: 'red',
                                        radius: 1
                                    }),
                                    text: new ol.style.Text({
                                        font: 30 + 'px Calibri,sans-serif',
                                        fill: new ol.style.Fill({ color: '#000' }),
                                        stroke: new ol.style.Stroke({
                                            color: '#fff', width: 2
                                        }),
                                        text: `${feature.get('count')}`
                                    })
                                }));
                                circleSource.addFeature(circle);
                                //return style of feature
                                return new ol.style.Style({
                                    stroke: new ol.style.Stroke({
                                        color: 'blue',
                                        width: 3,
                                    }),
                                    fill: null
                                });
                            }
                            else {
                                return new ol.style.Style({
                                    stroke: new ol.style.Stroke({
                                        color: 'blue',
                                        width: 3,
                                    }),
                                    fill: null
                                });
                            }
                        }
                    }
                });
                //Resolve the promise with the vector layer
                resolve(new ol.layer.Group({ layers: [vectorLayer, circleLayer] }));
            });
        });
    }
    function olToGeoJSON(feature) {
        return { type: feature.getGeometry().getType(), properties: feature.getProperties(), geometry: { type: 'Point', coordinates: feature.getGeometry().getCoordinates() } };
    }

}());
